// Code generated from RFC4512.g4 by ANTLR 4.13.1. DO NOT EDIT.

package rfc4512antlr // RFC4512
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type RFC4512Parser struct {
	*antlr.BaseParser
}

var RFC4512ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func rfc4512ParserInit() {
	staticData := &RFC4512ParserStaticData
	staticData.LiteralNames = []string{
		"", "';'",
	}
	staticData.SymbolicNames = []string{
		"", "", "OpenParenthesis", "CloseParenthesis", "ODelim", "Usage", "MacroSuffix",
		"NumOID", "ExtensionName", "QuotedDescriptor", "QuotedString", "MinUpperBounds",
		"Digit", "Descr", "DSRL", "DCRL", "NFL", "ATL", "OCL", "LSL", "MRL",
		"MRUL", "NOMODS", "SINGLEVAL", "STRUCTURAL", "COLLECTIVE", "AUXILIARY",
		"ABSTRACT", "OBSOLETE", "ORDERING", "EQUALITY", "APPLIES", "SYNTAX",
		"SUBSTR", "USAGE", "DESC", "NAME", "FORM", "MUST", "MAY", "NOT", "SUP",
		"AUX", "OC", "SP", "NEWLINE", "LineComment",
	}
	staticData.RuleNames = []string{
		"parse", "definitions", "objectClassDescriptions", "objectClassDescription",
		"oCKind", "abstractKind", "structuralKind", "auxiliaryKind", "oCSuperClasses",
		"attributeTypeDescriptions", "attributeTypeDescription", "minimumUpperBounds",
		"aTEquality", "aTOrdering", "aTSubstring", "aTSuperType", "aTUsage",
		"aTSingleValue", "aTCollective", "aTNoUserModification", "matchingRuleDescriptions",
		"matchingRuleDescription", "matchingRuleUseDescriptions", "matchingRuleUseDescription",
		"mRUApplies", "lDAPSyntaxDescriptions", "lDAPSyntaxDescription", "dITContentRuleDescriptions",
		"dITContentRuleDescription", "dCRNot", "dCRAux", "dITStructureRuleDescriptions",
		"dITStructureRuleDescription", "structureRules", "dSRSuperRules", "structureRule",
		"dSRForm", "nameFormDescriptions", "nameFormDescription", "nFStructuralOC",
		"definitionObsolete", "definitionSyntax", "definitionMust", "definitionMay",
		"definitionDescription", "definitionName", "definitionExtensions", "definitionExtension",
		"oIDs", "attributeDescription", "oID", "openParen", "closeParen", "numericOIDOrMacro",
		"macro", "numericOID", "macroSuffix", "number", "attrOptions", "descriptor",
		"extensionValue",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 46, 1844, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 1, 0, 3, 0, 124, 8, 0, 1, 0,
		3, 0, 127, 8, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 4, 1, 141, 8, 1, 11, 1, 12, 1, 142, 1, 2, 1, 2, 1, 2,
		5, 2, 148, 8, 2, 10, 2, 12, 2, 151, 9, 2, 1, 2, 1, 2, 4, 2, 155, 8, 2,
		11, 2, 12, 2, 156, 1, 3, 1, 3, 5, 3, 161, 8, 3, 10, 3, 12, 3, 164, 9, 3,
		1, 3, 3, 3, 167, 8, 3, 1, 3, 3, 3, 170, 8, 3, 1, 3, 5, 3, 173, 8, 3, 10,
		3, 12, 3, 176, 9, 3, 1, 3, 1, 3, 5, 3, 180, 8, 3, 10, 3, 12, 3, 183, 9,
		3, 1, 3, 3, 3, 186, 8, 3, 1, 3, 3, 3, 189, 8, 3, 1, 3, 1, 3, 5, 3, 193,
		8, 3, 10, 3, 12, 3, 196, 9, 3, 1, 3, 3, 3, 199, 8, 3, 1, 3, 3, 3, 202,
		8, 3, 3, 3, 204, 8, 3, 1, 3, 1, 3, 5, 3, 208, 8, 3, 10, 3, 12, 3, 211,
		9, 3, 1, 3, 3, 3, 214, 8, 3, 1, 3, 3, 3, 217, 8, 3, 3, 3, 219, 8, 3, 1,
		3, 1, 3, 5, 3, 223, 8, 3, 10, 3, 12, 3, 226, 9, 3, 1, 3, 3, 3, 229, 8,
		3, 1, 3, 3, 3, 232, 8, 3, 3, 3, 234, 8, 3, 1, 3, 1, 3, 5, 3, 238, 8, 3,
		10, 3, 12, 3, 241, 9, 3, 1, 3, 3, 3, 244, 8, 3, 1, 3, 3, 3, 247, 8, 3,
		3, 3, 249, 8, 3, 1, 3, 1, 3, 5, 3, 253, 8, 3, 10, 3, 12, 3, 256, 9, 3,
		1, 3, 3, 3, 259, 8, 3, 1, 3, 3, 3, 262, 8, 3, 3, 3, 264, 8, 3, 1, 3, 1,
		3, 5, 3, 268, 8, 3, 10, 3, 12, 3, 271, 9, 3, 1, 3, 3, 3, 274, 8, 3, 1,
		3, 3, 3, 277, 8, 3, 3, 3, 279, 8, 3, 1, 3, 1, 3, 5, 3, 283, 8, 3, 10, 3,
		12, 3, 286, 9, 3, 1, 3, 3, 3, 289, 8, 3, 1, 3, 3, 3, 292, 8, 3, 3, 3, 294,
		8, 3, 1, 3, 3, 3, 297, 8, 3, 1, 3, 5, 3, 300, 8, 3, 10, 3, 12, 3, 303,
		9, 3, 1, 3, 3, 3, 306, 8, 3, 1, 3, 3, 3, 309, 8, 3, 1, 3, 5, 3, 312, 8,
		3, 10, 3, 12, 3, 315, 9, 3, 1, 3, 3, 3, 318, 8, 3, 1, 3, 1, 3, 3, 3, 322,
		8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 327, 8, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7,
		1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 338, 8, 8, 1, 9, 1, 9, 1, 9, 5, 9, 343, 8,
		9, 10, 9, 12, 9, 346, 9, 9, 1, 9, 1, 9, 4, 9, 350, 8, 9, 11, 9, 12, 9,
		351, 1, 10, 1, 10, 5, 10, 356, 8, 10, 10, 10, 12, 10, 359, 9, 10, 1, 10,
		3, 10, 362, 8, 10, 1, 10, 3, 10, 365, 8, 10, 1, 10, 5, 10, 368, 8, 10,
		10, 10, 12, 10, 371, 9, 10, 1, 10, 1, 10, 5, 10, 375, 8, 10, 10, 10, 12,
		10, 378, 9, 10, 1, 10, 3, 10, 381, 8, 10, 1, 10, 3, 10, 384, 8, 10, 1,
		10, 1, 10, 5, 10, 388, 8, 10, 10, 10, 12, 10, 391, 9, 10, 1, 10, 3, 10,
		394, 8, 10, 1, 10, 3, 10, 397, 8, 10, 3, 10, 399, 8, 10, 1, 10, 1, 10,
		5, 10, 403, 8, 10, 10, 10, 12, 10, 406, 9, 10, 1, 10, 3, 10, 409, 8, 10,
		1, 10, 3, 10, 412, 8, 10, 3, 10, 414, 8, 10, 1, 10, 1, 10, 5, 10, 418,
		8, 10, 10, 10, 12, 10, 421, 9, 10, 1, 10, 3, 10, 424, 8, 10, 1, 10, 3,
		10, 427, 8, 10, 3, 10, 429, 8, 10, 1, 10, 1, 10, 5, 10, 433, 8, 10, 10,
		10, 12, 10, 436, 9, 10, 1, 10, 3, 10, 439, 8, 10, 1, 10, 3, 10, 442, 8,
		10, 3, 10, 444, 8, 10, 1, 10, 1, 10, 5, 10, 448, 8, 10, 10, 10, 12, 10,
		451, 9, 10, 1, 10, 3, 10, 454, 8, 10, 1, 10, 3, 10, 457, 8, 10, 3, 10,
		459, 8, 10, 1, 10, 1, 10, 5, 10, 463, 8, 10, 10, 10, 12, 10, 466, 9, 10,
		1, 10, 3, 10, 469, 8, 10, 1, 10, 3, 10, 472, 8, 10, 3, 10, 474, 8, 10,
		1, 10, 1, 10, 5, 10, 478, 8, 10, 10, 10, 12, 10, 481, 9, 10, 1, 10, 3,
		10, 484, 8, 10, 1, 10, 3, 10, 487, 8, 10, 3, 10, 489, 8, 10, 1, 10, 1,
		10, 3, 10, 493, 8, 10, 1, 10, 5, 10, 496, 8, 10, 10, 10, 12, 10, 499, 9,
		10, 1, 10, 3, 10, 502, 8, 10, 1, 10, 3, 10, 505, 8, 10, 3, 10, 507, 8,
		10, 1, 10, 1, 10, 3, 10, 511, 8, 10, 1, 10, 5, 10, 514, 8, 10, 10, 10,
		12, 10, 517, 9, 10, 1, 10, 3, 10, 520, 8, 10, 1, 10, 3, 10, 523, 8, 10,
		3, 10, 525, 8, 10, 1, 10, 1, 10, 5, 10, 529, 8, 10, 10, 10, 12, 10, 532,
		9, 10, 1, 10, 3, 10, 535, 8, 10, 1, 10, 3, 10, 538, 8, 10, 3, 10, 540,
		8, 10, 1, 10, 1, 10, 5, 10, 544, 8, 10, 10, 10, 12, 10, 547, 9, 10, 1,
		10, 3, 10, 550, 8, 10, 1, 10, 3, 10, 553, 8, 10, 3, 10, 555, 8, 10, 1,
		10, 3, 10, 558, 8, 10, 1, 10, 5, 10, 561, 8, 10, 10, 10, 12, 10, 564, 9,
		10, 1, 10, 3, 10, 567, 8, 10, 1, 10, 3, 10, 570, 8, 10, 1, 10, 5, 10, 573,
		8, 10, 10, 10, 12, 10, 576, 9, 10, 1, 10, 3, 10, 579, 8, 10, 1, 10, 1,
		10, 3, 10, 583, 8, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13,
		1, 13, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1,
		17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 5, 20, 611,
		8, 20, 10, 20, 12, 20, 614, 9, 20, 1, 20, 1, 20, 4, 20, 618, 8, 20, 11,
		20, 12, 20, 619, 1, 21, 1, 21, 5, 21, 624, 8, 21, 10, 21, 12, 21, 627,
		9, 21, 1, 21, 3, 21, 630, 8, 21, 1, 21, 3, 21, 633, 8, 21, 1, 21, 5, 21,
		636, 8, 21, 10, 21, 12, 21, 639, 9, 21, 1, 21, 1, 21, 5, 21, 643, 8, 21,
		10, 21, 12, 21, 646, 9, 21, 1, 21, 3, 21, 649, 8, 21, 1, 21, 3, 21, 652,
		8, 21, 1, 21, 1, 21, 5, 21, 656, 8, 21, 10, 21, 12, 21, 659, 9, 21, 1,
		21, 3, 21, 662, 8, 21, 1, 21, 3, 21, 665, 8, 21, 3, 21, 667, 8, 21, 1,
		21, 1, 21, 5, 21, 671, 8, 21, 10, 21, 12, 21, 674, 9, 21, 1, 21, 3, 21,
		677, 8, 21, 1, 21, 3, 21, 680, 8, 21, 3, 21, 682, 8, 21, 1, 21, 1, 21,
		5, 21, 686, 8, 21, 10, 21, 12, 21, 689, 9, 21, 1, 21, 3, 21, 692, 8, 21,
		1, 21, 3, 21, 695, 8, 21, 3, 21, 697, 8, 21, 1, 21, 1, 21, 5, 21, 701,
		8, 21, 10, 21, 12, 21, 704, 9, 21, 1, 21, 3, 21, 707, 8, 21, 1, 21, 3,
		21, 710, 8, 21, 3, 21, 712, 8, 21, 1, 21, 3, 21, 715, 8, 21, 1, 21, 5,
		21, 718, 8, 21, 10, 21, 12, 21, 721, 9, 21, 1, 21, 3, 21, 724, 8, 21, 1,
		21, 3, 21, 727, 8, 21, 1, 21, 5, 21, 730, 8, 21, 10, 21, 12, 21, 733, 9,
		21, 1, 21, 3, 21, 736, 8, 21, 1, 21, 1, 21, 3, 21, 740, 8, 21, 1, 22, 1,
		22, 1, 22, 5, 22, 745, 8, 22, 10, 22, 12, 22, 748, 9, 22, 1, 22, 1, 22,
		4, 22, 752, 8, 22, 11, 22, 12, 22, 753, 1, 23, 1, 23, 5, 23, 758, 8, 23,
		10, 23, 12, 23, 761, 9, 23, 1, 23, 3, 23, 764, 8, 23, 1, 23, 3, 23, 767,
		8, 23, 1, 23, 5, 23, 770, 8, 23, 10, 23, 12, 23, 773, 9, 23, 1, 23, 1,
		23, 5, 23, 777, 8, 23, 10, 23, 12, 23, 780, 9, 23, 1, 23, 3, 23, 783, 8,
		23, 1, 23, 3, 23, 786, 8, 23, 1, 23, 1, 23, 5, 23, 790, 8, 23, 10, 23,
		12, 23, 793, 9, 23, 1, 23, 3, 23, 796, 8, 23, 1, 23, 3, 23, 799, 8, 23,
		3, 23, 801, 8, 23, 1, 23, 1, 23, 5, 23, 805, 8, 23, 10, 23, 12, 23, 808,
		9, 23, 1, 23, 3, 23, 811, 8, 23, 1, 23, 3, 23, 814, 8, 23, 3, 23, 816,
		8, 23, 1, 23, 1, 23, 5, 23, 820, 8, 23, 10, 23, 12, 23, 823, 9, 23, 1,
		23, 3, 23, 826, 8, 23, 1, 23, 3, 23, 829, 8, 23, 3, 23, 831, 8, 23, 1,
		23, 1, 23, 5, 23, 835, 8, 23, 10, 23, 12, 23, 838, 9, 23, 1, 23, 3, 23,
		841, 8, 23, 1, 23, 3, 23, 844, 8, 23, 3, 23, 846, 8, 23, 1, 23, 3, 23,
		849, 8, 23, 1, 23, 5, 23, 852, 8, 23, 10, 23, 12, 23, 855, 9, 23, 1, 23,
		3, 23, 858, 8, 23, 1, 23, 3, 23, 861, 8, 23, 1, 23, 5, 23, 864, 8, 23,
		10, 23, 12, 23, 867, 9, 23, 1, 23, 3, 23, 870, 8, 23, 1, 23, 1, 23, 3,
		23, 874, 8, 23, 1, 24, 1, 24, 1, 24, 3, 24, 879, 8, 24, 1, 25, 1, 25, 1,
		25, 5, 25, 884, 8, 25, 10, 25, 12, 25, 887, 9, 25, 1, 25, 1, 25, 4, 25,
		891, 8, 25, 11, 25, 12, 25, 892, 1, 26, 1, 26, 5, 26, 897, 8, 26, 10, 26,
		12, 26, 900, 9, 26, 1, 26, 3, 26, 903, 8, 26, 1, 26, 3, 26, 906, 8, 26,
		1, 26, 5, 26, 909, 8, 26, 10, 26, 12, 26, 912, 9, 26, 1, 26, 1, 26, 5,
		26, 916, 8, 26, 10, 26, 12, 26, 919, 9, 26, 1, 26, 3, 26, 922, 8, 26, 1,
		26, 3, 26, 925, 8, 26, 1, 26, 1, 26, 5, 26, 929, 8, 26, 10, 26, 12, 26,
		932, 9, 26, 1, 26, 3, 26, 935, 8, 26, 1, 26, 3, 26, 938, 8, 26, 3, 26,
		940, 8, 26, 1, 26, 3, 26, 943, 8, 26, 1, 26, 5, 26, 946, 8, 26, 10, 26,
		12, 26, 949, 9, 26, 1, 26, 3, 26, 952, 8, 26, 1, 26, 3, 26, 955, 8, 26,
		1, 26, 5, 26, 958, 8, 26, 10, 26, 12, 26, 961, 9, 26, 1, 26, 3, 26, 964,
		8, 26, 1, 26, 1, 26, 3, 26, 968, 8, 26, 1, 27, 1, 27, 1, 27, 5, 27, 973,
		8, 27, 10, 27, 12, 27, 976, 9, 27, 1, 27, 1, 27, 4, 27, 980, 8, 27, 11,
		27, 12, 27, 981, 1, 28, 1, 28, 5, 28, 986, 8, 28, 10, 28, 12, 28, 989,
		9, 28, 1, 28, 3, 28, 992, 8, 28, 1, 28, 3, 28, 995, 8, 28, 1, 28, 5, 28,
		998, 8, 28, 10, 28, 12, 28, 1001, 9, 28, 1, 28, 1, 28, 5, 28, 1005, 8,
		28, 10, 28, 12, 28, 1008, 9, 28, 1, 28, 3, 28, 1011, 8, 28, 1, 28, 3, 28,
		1014, 8, 28, 1, 28, 1, 28, 5, 28, 1018, 8, 28, 10, 28, 12, 28, 1021, 9,
		28, 1, 28, 3, 28, 1024, 8, 28, 1, 28, 3, 28, 1027, 8, 28, 3, 28, 1029,
		8, 28, 1, 28, 1, 28, 5, 28, 1033, 8, 28, 10, 28, 12, 28, 1036, 9, 28, 1,
		28, 3, 28, 1039, 8, 28, 1, 28, 3, 28, 1042, 8, 28, 3, 28, 1044, 8, 28,
		1, 28, 1, 28, 5, 28, 1048, 8, 28, 10, 28, 12, 28, 1051, 9, 28, 1, 28, 3,
		28, 1054, 8, 28, 1, 28, 3, 28, 1057, 8, 28, 3, 28, 1059, 8, 28, 1, 28,
		1, 28, 5, 28, 1063, 8, 28, 10, 28, 12, 28, 1066, 9, 28, 1, 28, 3, 28, 1069,
		8, 28, 1, 28, 3, 28, 1072, 8, 28, 3, 28, 1074, 8, 28, 1, 28, 1, 28, 5,
		28, 1078, 8, 28, 10, 28, 12, 28, 1081, 9, 28, 1, 28, 3, 28, 1084, 8, 28,
		1, 28, 3, 28, 1087, 8, 28, 3, 28, 1089, 8, 28, 1, 28, 1, 28, 5, 28, 1093,
		8, 28, 10, 28, 12, 28, 1096, 9, 28, 1, 28, 3, 28, 1099, 8, 28, 1, 28, 3,
		28, 1102, 8, 28, 3, 28, 1104, 8, 28, 1, 28, 1, 28, 5, 28, 1108, 8, 28,
		10, 28, 12, 28, 1111, 9, 28, 1, 28, 3, 28, 1114, 8, 28, 1, 28, 3, 28, 1117,
		8, 28, 3, 28, 1119, 8, 28, 1, 28, 3, 28, 1122, 8, 28, 1, 28, 5, 28, 1125,
		8, 28, 10, 28, 12, 28, 1128, 9, 28, 1, 28, 3, 28, 1131, 8, 28, 1, 28, 3,
		28, 1134, 8, 28, 1, 28, 5, 28, 1137, 8, 28, 10, 28, 12, 28, 1140, 9, 28,
		1, 28, 3, 28, 1143, 8, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 3, 29, 1150,
		8, 29, 1, 30, 1, 30, 1, 30, 3, 30, 1155, 8, 30, 1, 31, 1, 31, 1, 31, 5,
		31, 1160, 8, 31, 10, 31, 12, 31, 1163, 9, 31, 1, 31, 1, 31, 4, 31, 1167,
		8, 31, 11, 31, 12, 31, 1168, 1, 32, 1, 32, 5, 32, 1173, 8, 32, 10, 32,
		12, 32, 1176, 9, 32, 1, 32, 3, 32, 1179, 8, 32, 1, 32, 3, 32, 1182, 8,
		32, 1, 32, 5, 32, 1185, 8, 32, 10, 32, 12, 32, 1188, 9, 32, 1, 32, 1, 32,
		5, 32, 1192, 8, 32, 10, 32, 12, 32, 1195, 9, 32, 1, 32, 3, 32, 1198, 8,
		32, 1, 32, 3, 32, 1201, 8, 32, 1, 32, 1, 32, 5, 32, 1205, 8, 32, 10, 32,
		12, 32, 1208, 9, 32, 1, 32, 3, 32, 1211, 8, 32, 1, 32, 3, 32, 1214, 8,
		32, 3, 32, 1216, 8, 32, 1, 32, 1, 32, 5, 32, 1220, 8, 32, 10, 32, 12, 32,
		1223, 9, 32, 1, 32, 3, 32, 1226, 8, 32, 1, 32, 3, 32, 1229, 8, 32, 3, 32,
		1231, 8, 32, 1, 32, 1, 32, 5, 32, 1235, 8, 32, 10, 32, 12, 32, 1238, 9,
		32, 1, 32, 3, 32, 1241, 8, 32, 1, 32, 3, 32, 1244, 8, 32, 3, 32, 1246,
		8, 32, 1, 32, 1, 32, 5, 32, 1250, 8, 32, 10, 32, 12, 32, 1253, 9, 32, 1,
		32, 3, 32, 1256, 8, 32, 1, 32, 3, 32, 1259, 8, 32, 1, 32, 1, 32, 5, 32,
		1263, 8, 32, 10, 32, 12, 32, 1266, 9, 32, 1, 32, 3, 32, 1269, 8, 32, 1,
		32, 3, 32, 1272, 8, 32, 3, 32, 1274, 8, 32, 1, 32, 3, 32, 1277, 8, 32,
		1, 32, 5, 32, 1280, 8, 32, 10, 32, 12, 32, 1283, 9, 32, 1, 32, 3, 32, 1286,
		8, 32, 1, 32, 3, 32, 1289, 8, 32, 1, 32, 5, 32, 1292, 8, 32, 10, 32, 12,
		32, 1295, 9, 32, 1, 32, 3, 32, 1298, 8, 32, 1, 32, 1, 32, 3, 32, 1302,
		8, 32, 1, 33, 1, 33, 5, 33, 1306, 8, 33, 10, 33, 12, 33, 1309, 9, 33, 1,
		33, 3, 33, 1312, 8, 33, 1, 33, 3, 33, 1315, 8, 33, 1, 33, 5, 33, 1318,
		8, 33, 10, 33, 12, 33, 1321, 9, 33, 1, 33, 3, 33, 1324, 8, 33, 1, 33, 1,
		33, 5, 33, 1328, 8, 33, 10, 33, 12, 33, 1331, 9, 33, 1, 33, 3, 33, 1334,
		8, 33, 1, 33, 3, 33, 1337, 8, 33, 1, 33, 4, 33, 1340, 8, 33, 11, 33, 12,
		33, 1341, 1, 33, 5, 33, 1345, 8, 33, 10, 33, 12, 33, 1348, 9, 33, 1, 33,
		5, 33, 1351, 8, 33, 10, 33, 12, 33, 1354, 9, 33, 1, 33, 3, 33, 1357, 8,
		33, 1, 33, 3, 33, 1360, 8, 33, 1, 33, 5, 33, 1363, 8, 33, 10, 33, 12, 33,
		1366, 9, 33, 1, 33, 1, 33, 5, 33, 1370, 8, 33, 10, 33, 12, 33, 1373, 9,
		33, 1, 33, 3, 33, 1376, 8, 33, 1, 34, 1, 34, 1, 34, 3, 34, 1381, 8, 34,
		1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 5, 37, 1391, 8,
		37, 10, 37, 12, 37, 1394, 9, 37, 1, 37, 1, 37, 4, 37, 1398, 8, 37, 11,
		37, 12, 37, 1399, 1, 38, 1, 38, 5, 38, 1404, 8, 38, 10, 38, 12, 38, 1407,
		9, 38, 1, 38, 3, 38, 1410, 8, 38, 1, 38, 3, 38, 1413, 8, 38, 1, 38, 5,
		38, 1416, 8, 38, 10, 38, 12, 38, 1419, 9, 38, 1, 38, 1, 38, 5, 38, 1423,
		8, 38, 10, 38, 12, 38, 1426, 9, 38, 1, 38, 3, 38, 1429, 8, 38, 1, 38, 3,
		38, 1432, 8, 38, 1, 38, 1, 38, 5, 38, 1436, 8, 38, 10, 38, 12, 38, 1439,
		9, 38, 1, 38, 3, 38, 1442, 8, 38, 1, 38, 3, 38, 1445, 8, 38, 3, 38, 1447,
		8, 38, 1, 38, 1, 38, 5, 38, 1451, 8, 38, 10, 38, 12, 38, 1454, 9, 38, 1,
		38, 3, 38, 1457, 8, 38, 1, 38, 3, 38, 1460, 8, 38, 3, 38, 1462, 8, 38,
		1, 38, 1, 38, 5, 38, 1466, 8, 38, 10, 38, 12, 38, 1469, 9, 38, 1, 38, 3,
		38, 1472, 8, 38, 1, 38, 3, 38, 1475, 8, 38, 3, 38, 1477, 8, 38, 1, 38,
		1, 38, 5, 38, 1481, 8, 38, 10, 38, 12, 38, 1484, 9, 38, 1, 38, 3, 38, 1487,
		8, 38, 1, 38, 3, 38, 1490, 8, 38, 1, 38, 1, 38, 5, 38, 1494, 8, 38, 10,
		38, 12, 38, 1497, 9, 38, 1, 38, 3, 38, 1500, 8, 38, 1, 38, 3, 38, 1503,
		8, 38, 1, 38, 1, 38, 5, 38, 1507, 8, 38, 10, 38, 12, 38, 1510, 9, 38, 1,
		38, 3, 38, 1513, 8, 38, 1, 38, 3, 38, 1516, 8, 38, 3, 38, 1518, 8, 38,
		1, 38, 3, 38, 1521, 8, 38, 1, 38, 5, 38, 1524, 8, 38, 10, 38, 12, 38, 1527,
		9, 38, 1, 38, 3, 38, 1530, 8, 38, 1, 38, 3, 38, 1533, 8, 38, 1, 38, 5,
		38, 1536, 8, 38, 10, 38, 12, 38, 1539, 9, 38, 1, 38, 3, 38, 1542, 8, 38,
		1, 38, 1, 38, 3, 38, 1546, 8, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1,
		41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 3, 42, 1559, 8, 42, 1, 43, 1, 43,
		1, 43, 3, 43, 1564, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1,
		45, 5, 45, 1573, 8, 45, 10, 45, 12, 45, 1576, 9, 45, 1, 45, 3, 45, 1579,
		8, 45, 1, 45, 3, 45, 1582, 8, 45, 1, 45, 5, 45, 1585, 8, 45, 10, 45, 12,
		45, 1588, 9, 45, 1, 45, 3, 45, 1591, 8, 45, 1, 45, 1, 45, 5, 45, 1595,
		8, 45, 10, 45, 12, 45, 1598, 9, 45, 1, 45, 3, 45, 1601, 8, 45, 1, 45, 3,
		45, 1604, 8, 45, 1, 45, 4, 45, 1607, 8, 45, 11, 45, 12, 45, 1608, 1, 45,
		5, 45, 1612, 8, 45, 10, 45, 12, 45, 1615, 9, 45, 1, 45, 5, 45, 1618, 8,
		45, 10, 45, 12, 45, 1621, 9, 45, 1, 45, 3, 45, 1624, 8, 45, 1, 45, 3, 45,
		1627, 8, 45, 1, 45, 5, 45, 1630, 8, 45, 10, 45, 12, 45, 1633, 9, 45, 1,
		45, 1, 45, 5, 45, 1637, 8, 45, 10, 45, 12, 45, 1640, 9, 45, 1, 45, 3, 45,
		1643, 8, 45, 3, 45, 1645, 8, 45, 1, 46, 4, 46, 1648, 8, 46, 11, 46, 12,
		46, 1649, 1, 47, 3, 47, 1653, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47,
		1659, 8, 47, 10, 47, 12, 47, 1662, 9, 47, 1, 47, 3, 47, 1665, 8, 47, 1,
		47, 3, 47, 1668, 8, 47, 1, 47, 5, 47, 1671, 8, 47, 10, 47, 12, 47, 1674,
		9, 47, 1, 47, 3, 47, 1677, 8, 47, 1, 47, 1, 47, 5, 47, 1681, 8, 47, 10,
		47, 12, 47, 1684, 9, 47, 1, 47, 3, 47, 1687, 8, 47, 1, 47, 3, 47, 1690,
		8, 47, 1, 47, 4, 47, 1693, 8, 47, 11, 47, 12, 47, 1694, 1, 47, 5, 47, 1698,
		8, 47, 10, 47, 12, 47, 1701, 9, 47, 1, 47, 5, 47, 1704, 8, 47, 10, 47,
		12, 47, 1707, 9, 47, 1, 47, 3, 47, 1710, 8, 47, 1, 47, 3, 47, 1713, 8,
		47, 1, 47, 5, 47, 1716, 8, 47, 10, 47, 12, 47, 1719, 9, 47, 1, 47, 1, 47,
		5, 47, 1723, 8, 47, 10, 47, 12, 47, 1726, 9, 47, 1, 47, 3, 47, 1729, 8,
		47, 3, 47, 1731, 8, 47, 1, 48, 1, 48, 5, 48, 1735, 8, 48, 10, 48, 12, 48,
		1738, 9, 48, 1, 48, 3, 48, 1741, 8, 48, 1, 48, 3, 48, 1744, 8, 48, 1, 48,
		5, 48, 1747, 8, 48, 10, 48, 12, 48, 1750, 9, 48, 1, 48, 1, 48, 5, 48, 1754,
		8, 48, 10, 48, 12, 48, 1757, 9, 48, 1, 48, 3, 48, 1760, 8, 48, 1, 48, 3,
		48, 1763, 8, 48, 1, 48, 1, 48, 5, 48, 1767, 8, 48, 10, 48, 12, 48, 1770,
		9, 48, 1, 48, 5, 48, 1773, 8, 48, 10, 48, 12, 48, 1776, 9, 48, 1, 48, 5,
		48, 1779, 8, 48, 10, 48, 12, 48, 1782, 9, 48, 1, 48, 3, 48, 1785, 8, 48,
		1, 48, 3, 48, 1788, 8, 48, 1, 48, 5, 48, 1791, 8, 48, 10, 48, 12, 48, 1794,
		9, 48, 1, 48, 3, 48, 1797, 8, 48, 1, 48, 1, 48, 5, 48, 1801, 8, 48, 10,
		48, 12, 48, 1804, 9, 48, 1, 48, 3, 48, 1807, 8, 48, 1, 49, 1, 49, 3, 49,
		1811, 8, 49, 1, 50, 1, 50, 3, 50, 1815, 8, 50, 1, 51, 1, 51, 1, 52, 1,
		52, 1, 53, 1, 53, 3, 53, 1823, 8, 53, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55,
		1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 4, 58, 1836, 8, 58, 11, 58, 12,
		58, 1837, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 0, 0, 61, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 0, 2, 1, 1, 45, 45, 1, 0, 9, 10, 2180, 0, 123, 1, 0, 0,
		0, 2, 140, 1, 0, 0, 0, 4, 154, 1, 0, 0, 0, 6, 158, 1, 0, 0, 0, 8, 326,
		1, 0, 0, 0, 10, 328, 1, 0, 0, 0, 12, 330, 1, 0, 0, 0, 14, 332, 1, 0, 0,
		0, 16, 334, 1, 0, 0, 0, 18, 349, 1, 0, 0, 0, 20, 353, 1, 0, 0, 0, 22, 584,
		1, 0, 0, 0, 24, 586, 1, 0, 0, 0, 26, 589, 1, 0, 0, 0, 28, 592, 1, 0, 0,
		0, 30, 595, 1, 0, 0, 0, 32, 598, 1, 0, 0, 0, 34, 601, 1, 0, 0, 0, 36, 603,
		1, 0, 0, 0, 38, 605, 1, 0, 0, 0, 40, 617, 1, 0, 0, 0, 42, 621, 1, 0, 0,
		0, 44, 751, 1, 0, 0, 0, 46, 755, 1, 0, 0, 0, 48, 875, 1, 0, 0, 0, 50, 890,
		1, 0, 0, 0, 52, 894, 1, 0, 0, 0, 54, 979, 1, 0, 0, 0, 56, 983, 1, 0, 0,
		0, 58, 1146, 1, 0, 0, 0, 60, 1151, 1, 0, 0, 0, 62, 1166, 1, 0, 0, 0, 64,
		1170, 1, 0, 0, 0, 66, 1303, 1, 0, 0, 0, 68, 1377, 1, 0, 0, 0, 70, 1382,
		1, 0, 0, 0, 72, 1384, 1, 0, 0, 0, 74, 1397, 1, 0, 0, 0, 76, 1401, 1, 0,
		0, 0, 78, 1547, 1, 0, 0, 0, 80, 1550, 1, 0, 0, 0, 82, 1552, 1, 0, 0, 0,
		84, 1555, 1, 0, 0, 0, 86, 1560, 1, 0, 0, 0, 88, 1565, 1, 0, 0, 0, 90, 1568,
		1, 0, 0, 0, 92, 1647, 1, 0, 0, 0, 94, 1652, 1, 0, 0, 0, 96, 1732, 1, 0,
		0, 0, 98, 1808, 1, 0, 0, 0, 100, 1814, 1, 0, 0, 0, 102, 1816, 1, 0, 0,
		0, 104, 1818, 1, 0, 0, 0, 106, 1822, 1, 0, 0, 0, 108, 1824, 1, 0, 0, 0,
		110, 1827, 1, 0, 0, 0, 112, 1829, 1, 0, 0, 0, 114, 1831, 1, 0, 0, 0, 116,
		1835, 1, 0, 0, 0, 118, 1839, 1, 0, 0, 0, 120, 1841, 1, 0, 0, 0, 122, 124,
		5, 45, 0, 0, 123, 122, 1, 0, 0, 0, 123, 124, 1, 0, 0, 0, 124, 126, 1, 0,
		0, 0, 125, 127, 5, 46, 0, 0, 126, 125, 1, 0, 0, 0, 126, 127, 1, 0, 0, 0,
		127, 128, 1, 0, 0, 0, 128, 129, 3, 2, 1, 0, 129, 130, 5, 0, 0, 1, 130,
		1, 1, 0, 0, 0, 131, 141, 5, 46, 0, 0, 132, 141, 3, 50, 25, 0, 133, 141,
		3, 40, 20, 0, 134, 141, 3, 18, 9, 0, 135, 141, 3, 44, 22, 0, 136, 141,
		3, 4, 2, 0, 137, 141, 3, 54, 27, 0, 138, 141, 3, 74, 37, 0, 139, 141, 3,
		62, 31, 0, 140, 131, 1, 0, 0, 0, 140, 132, 1, 0, 0, 0, 140, 133, 1, 0,
		0, 0, 140, 134, 1, 0, 0, 0, 140, 135, 1, 0, 0, 0, 140, 136, 1, 0, 0, 0,
		140, 137, 1, 0, 0, 0, 140, 138, 1, 0, 0, 0, 140, 139, 1, 0, 0, 0, 141,
		142, 1, 0, 0, 0, 142, 140, 1, 0, 0, 0, 142, 143, 1, 0, 0, 0, 143, 3, 1,
		0, 0, 0, 144, 145, 5, 18, 0, 0, 145, 149, 3, 6, 3, 0, 146, 148, 5, 44,
		0, 0, 147, 146, 1, 0, 0, 0, 148, 151, 1, 0, 0, 0, 149, 147, 1, 0, 0, 0,
		149, 150, 1, 0, 0, 0, 150, 152, 1, 0, 0, 0, 151, 149, 1, 0, 0, 0, 152,
		153, 7, 0, 0, 0, 153, 155, 1, 0, 0, 0, 154, 144, 1, 0, 0, 0, 155, 156,
		1, 0, 0, 0, 156, 154, 1, 0, 0, 0, 156, 157, 1, 0, 0, 0, 157, 5, 1, 0, 0,
		0, 158, 162, 3, 102, 51, 0, 159, 161, 5, 44, 0, 0, 160, 159, 1, 0, 0, 0,
		161, 164, 1, 0, 0, 0, 162, 160, 1, 0, 0, 0, 162, 163, 1, 0, 0, 0, 163,
		166, 1, 0, 0, 0, 164, 162, 1, 0, 0, 0, 165, 167, 5, 46, 0, 0, 166, 165,
		1, 0, 0, 0, 166, 167, 1, 0, 0, 0, 167, 169, 1, 0, 0, 0, 168, 170, 5, 45,
		0, 0, 169, 168, 1, 0, 0, 0, 169, 170, 1, 0, 0, 0, 170, 174, 1, 0, 0, 0,
		171, 173, 5, 44, 0, 0, 172, 171, 1, 0, 0, 0, 173, 176, 1, 0, 0, 0, 174,
		172, 1, 0, 0, 0, 174, 175, 1, 0, 0, 0, 175, 177, 1, 0, 0, 0, 176, 174,
		1, 0, 0, 0, 177, 181, 3, 106, 53, 0, 178, 180, 5, 44, 0, 0, 179, 178, 1,
		0, 0, 0, 180, 183, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 181, 182, 1, 0, 0,
		0, 182, 185, 1, 0, 0, 0, 183, 181, 1, 0, 0, 0, 184, 186, 5, 46, 0, 0, 185,
		184, 1, 0, 0, 0, 185, 186, 1, 0, 0, 0, 186, 188, 1, 0, 0, 0, 187, 189,
		5, 45, 0, 0, 188, 187, 1, 0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 203, 1, 0,
		0, 0, 190, 194, 3, 90, 45, 0, 191, 193, 5, 44, 0, 0, 192, 191, 1, 0, 0,
		0, 193, 196, 1, 0, 0, 0, 194, 192, 1, 0, 0, 0, 194, 195, 1, 0, 0, 0, 195,
		198, 1, 0, 0, 0, 196, 194, 1, 0, 0, 0, 197, 199, 5, 46, 0, 0, 198, 197,
		1, 0, 0, 0, 198, 199, 1, 0, 0, 0, 199, 201, 1, 0, 0, 0, 200, 202, 5, 45,
		0, 0, 201, 200, 1, 0, 0, 0, 201, 202, 1, 0, 0, 0, 202, 204, 1, 0, 0, 0,
		203, 190, 1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204, 218, 1, 0, 0, 0, 205,
		209, 3, 88, 44, 0, 206, 208, 5, 44, 0, 0, 207, 206, 1, 0, 0, 0, 208, 211,
		1, 0, 0, 0, 209, 207, 1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210, 213, 1, 0,
		0, 0, 211, 209, 1, 0, 0, 0, 212, 214, 5, 46, 0, 0, 213, 212, 1, 0, 0, 0,
		213, 214, 1, 0, 0, 0, 214, 216, 1, 0, 0, 0, 215, 217, 5, 45, 0, 0, 216,
		215, 1, 0, 0, 0, 216, 217, 1, 0, 0, 0, 217, 219, 1, 0, 0, 0, 218, 205,
		1, 0, 0, 0, 218, 219, 1, 0, 0, 0, 219, 233, 1, 0, 0, 0, 220, 224, 3, 80,
		40, 0, 221, 223, 5, 44, 0, 0, 222, 221, 1, 0, 0, 0, 223, 226, 1, 0, 0,
		0, 224, 222, 1, 0, 0, 0, 224, 225, 1, 0, 0, 0, 225, 228, 1, 0, 0, 0, 226,
		224, 1, 0, 0, 0, 227, 229, 5, 46, 0, 0, 228, 227, 1, 0, 0, 0, 228, 229,
		1, 0, 0, 0, 229, 231, 1, 0, 0, 0, 230, 232, 5, 45, 0, 0, 231, 230, 1, 0,
		0, 0, 231, 232, 1, 0, 0, 0, 232, 234, 1, 0, 0, 0, 233, 220, 1, 0, 0, 0,
		233, 234, 1, 0, 0, 0, 234, 248, 1, 0, 0, 0, 235, 239, 3, 16, 8, 0, 236,
		238, 5, 44, 0, 0, 237, 236, 1, 0, 0, 0, 238, 241, 1, 0, 0, 0, 239, 237,
		1, 0, 0, 0, 239, 240, 1, 0, 0, 0, 240, 243, 1, 0, 0, 0, 241, 239, 1, 0,
		0, 0, 242, 244, 5, 46, 0, 0, 243, 242, 1, 0, 0, 0, 243, 244, 1, 0, 0, 0,
		244, 246, 1, 0, 0, 0, 245, 247, 5, 45, 0, 0, 246, 245, 1, 0, 0, 0, 246,
		247, 1, 0, 0, 0, 247, 249, 1, 0, 0, 0, 248, 235, 1, 0, 0, 0, 248, 249,
		1, 0, 0, 0, 249, 263, 1, 0, 0, 0, 250, 254, 3, 8, 4, 0, 251, 253, 5, 44,
		0, 0, 252, 251, 1, 0, 0, 0, 253, 256, 1, 0, 0, 0, 254, 252, 1, 0, 0, 0,
		254, 255, 1, 0, 0, 0, 255, 258, 1, 0, 0, 0, 256, 254, 1, 0, 0, 0, 257,
		259, 5, 46, 0, 0, 258, 257, 1, 0, 0, 0, 258, 259, 1, 0, 0, 0, 259, 261,
		1, 0, 0, 0, 260, 262, 5, 45, 0, 0, 261, 260, 1, 0, 0, 0, 261, 262, 1, 0,
		0, 0, 262, 264, 1, 0, 0, 0, 263, 250, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0,
		264, 278, 1, 0, 0, 0, 265, 269, 3, 84, 42, 0, 266, 268, 5, 44, 0, 0, 267,
		266, 1, 0, 0, 0, 268, 271, 1, 0, 0, 0, 269, 267, 1, 0, 0, 0, 269, 270,
		1, 0, 0, 0, 270, 273, 1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 272, 274, 5, 46,
		0, 0, 273, 272, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 274, 276, 1, 0, 0, 0,
		275, 277, 5, 45, 0, 0, 276, 275, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277,
		279, 1, 0, 0, 0, 278, 265, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 293,
		1, 0, 0, 0, 280, 284, 3, 86, 43, 0, 281, 283, 5, 44, 0, 0, 282, 281, 1,
		0, 0, 0, 283, 286, 1, 0, 0, 0, 284, 282, 1, 0, 0, 0, 284, 285, 1, 0, 0,
		0, 285, 288, 1, 0, 0, 0, 286, 284, 1, 0, 0, 0, 287, 289, 5, 46, 0, 0, 288,
		287, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 291, 1, 0, 0, 0, 290, 292,
		5, 45, 0, 0, 291, 290, 1, 0, 0, 0, 291, 292, 1, 0, 0, 0, 292, 294, 1, 0,
		0, 0, 293, 280, 1, 0, 0, 0, 293, 294, 1, 0, 0, 0, 294, 296, 1, 0, 0, 0,
		295, 297, 3, 92, 46, 0, 296, 295, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297,
		301, 1, 0, 0, 0, 298, 300, 5, 44, 0, 0, 299, 298, 1, 0, 0, 0, 300, 303,
		1, 0, 0, 0, 301, 299, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0, 302, 305, 1, 0,
		0, 0, 303, 301, 1, 0, 0, 0, 304, 306, 5, 46, 0, 0, 305, 304, 1, 0, 0, 0,
		305, 306, 1, 0, 0, 0, 306, 308, 1, 0, 0, 0, 307, 309, 5, 45, 0, 0, 308,
		307, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309, 313, 1, 0, 0, 0, 310, 312,
		5, 44, 0, 0, 311, 310, 1, 0, 0, 0, 312, 315, 1, 0, 0, 0, 313, 311, 1, 0,
		0, 0, 313, 314, 1, 0, 0, 0, 314, 317, 1, 0, 0, 0, 315, 313, 1, 0, 0, 0,
		316, 318, 5, 46, 0, 0, 317, 316, 1, 0, 0, 0, 317, 318, 1, 0, 0, 0, 318,
		319, 1, 0, 0, 0, 319, 321, 3, 104, 52, 0, 320, 322, 5, 46, 0, 0, 321, 320,
		1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 7, 1, 0, 0, 0, 323, 327, 3, 12,
		6, 0, 324, 327, 3, 14, 7, 0, 325, 327, 3, 10, 5, 0, 326, 323, 1, 0, 0,
		0, 326, 324, 1, 0, 0, 0, 326, 325, 1, 0, 0, 0, 327, 9, 1, 0, 0, 0, 328,
		329, 5, 27, 0, 0, 329, 11, 1, 0, 0, 0, 330, 331, 5, 24, 0, 0, 331, 13,
		1, 0, 0, 0, 332, 333, 5, 26, 0, 0, 333, 15, 1, 0, 0, 0, 334, 337, 5, 41,
		0, 0, 335, 338, 3, 100, 50, 0, 336, 338, 3, 96, 48, 0, 337, 335, 1, 0,
		0, 0, 337, 336, 1, 0, 0, 0, 338, 17, 1, 0, 0, 0, 339, 340, 5, 17, 0, 0,
		340, 344, 3, 20, 10, 0, 341, 343, 5, 44, 0, 0, 342, 341, 1, 0, 0, 0, 343,
		346, 1, 0, 0, 0, 344, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 347,
		1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 347, 348, 7, 0, 0, 0, 348, 350, 1, 0,
		0, 0, 349, 339, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 349, 1, 0, 0, 0,
		351, 352, 1, 0, 0, 0, 352, 19, 1, 0, 0, 0, 353, 357, 3, 102, 51, 0, 354,
		356, 5, 44, 0, 0, 355, 354, 1, 0, 0, 0, 356, 359, 1, 0, 0, 0, 357, 355,
		1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 361, 1, 0, 0, 0, 359, 357, 1, 0,
		0, 0, 360, 362, 5, 46, 0, 0, 361, 360, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0,
		362, 364, 1, 0, 0, 0, 363, 365, 5, 45, 0, 0, 364, 363, 1, 0, 0, 0, 364,
		365, 1, 0, 0, 0, 365, 369, 1, 0, 0, 0, 366, 368, 5, 44, 0, 0, 367, 366,
		1, 0, 0, 0, 368, 371, 1, 0, 0, 0, 369, 367, 1, 0, 0, 0, 369, 370, 1, 0,
		0, 0, 370, 372, 1, 0, 0, 0, 371, 369, 1, 0, 0, 0, 372, 376, 3, 106, 53,
		0, 373, 375, 5, 44, 0, 0, 374, 373, 1, 0, 0, 0, 375, 378, 1, 0, 0, 0, 376,
		374, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 380, 1, 0, 0, 0, 378, 376,
		1, 0, 0, 0, 379, 381, 5, 46, 0, 0, 380, 379, 1, 0, 0, 0, 380, 381, 1, 0,
		0, 0, 381, 383, 1, 0, 0, 0, 382, 384, 5, 45, 0, 0, 383, 382, 1, 0, 0, 0,
		383, 384, 1, 0, 0, 0, 384, 398, 1, 0, 0, 0, 385, 389, 3, 90, 45, 0, 386,
		388, 5, 44, 0, 0, 387, 386, 1, 0, 0, 0, 388, 391, 1, 0, 0, 0, 389, 387,
		1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 393, 1, 0, 0, 0, 391, 389, 1, 0,
		0, 0, 392, 394, 5, 46, 0, 0, 393, 392, 1, 0, 0, 0, 393, 394, 1, 0, 0, 0,
		394, 396, 1, 0, 0, 0, 395, 397, 5, 45, 0, 0, 396, 395, 1, 0, 0, 0, 396,
		397, 1, 0, 0, 0, 397, 399, 1, 0, 0, 0, 398, 385, 1, 0, 0, 0, 398, 399,
		1, 0, 0, 0, 399, 413, 1, 0, 0, 0, 400, 404, 3, 88, 44, 0, 401, 403, 5,
		44, 0, 0, 402, 401, 1, 0, 0, 0, 403, 406, 1, 0, 0, 0, 404, 402, 1, 0, 0,
		0, 404, 405, 1, 0, 0, 0, 405, 408, 1, 0, 0, 0, 406, 404, 1, 0, 0, 0, 407,
		409, 5, 46, 0, 0, 408, 407, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 411,
		1, 0, 0, 0, 410, 412, 5, 45, 0, 0, 411, 410, 1, 0, 0, 0, 411, 412, 1, 0,
		0, 0, 412, 414, 1, 0, 0, 0, 413, 400, 1, 0, 0, 0, 413, 414, 1, 0, 0, 0,
		414, 428, 1, 0, 0, 0, 415, 419, 3, 80, 40, 0, 416, 418, 5, 44, 0, 0, 417,
		416, 1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 419, 420,
		1, 0, 0, 0, 420, 423, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 422, 424, 5, 46,
		0, 0, 423, 422, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424, 426, 1, 0, 0, 0,
		425, 427, 5, 45, 0, 0, 426, 425, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427,
		429, 1, 0, 0, 0, 428, 415, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 443,
		1, 0, 0, 0, 430, 434, 3, 30, 15, 0, 431, 433, 5, 44, 0, 0, 432, 431, 1,
		0, 0, 0, 433, 436, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 434, 435, 1, 0, 0,
		0, 435, 438, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 437, 439, 5, 46, 0, 0, 438,
		437, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 441, 1, 0, 0, 0, 440, 442,
		5, 45, 0, 0, 441, 440, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 444, 1, 0,
		0, 0, 443, 430, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 458, 1, 0, 0, 0,
		445, 449, 3, 24, 12, 0, 446, 448, 5, 44, 0, 0, 447, 446, 1, 0, 0, 0, 448,
		451, 1, 0, 0, 0, 449, 447, 1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 453,
		1, 0, 0, 0, 451, 449, 1, 0, 0, 0, 452, 454, 5, 46, 0, 0, 453, 452, 1, 0,
		0, 0, 453, 454, 1, 0, 0, 0, 454, 456, 1, 0, 0, 0, 455, 457, 5, 45, 0, 0,
		456, 455, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 459, 1, 0, 0, 0, 458,
		445, 1, 0, 0, 0, 458, 459, 1, 0, 0, 0, 459, 473, 1, 0, 0, 0, 460, 464,
		3, 26, 13, 0, 461, 463, 5, 44, 0, 0, 462, 461, 1, 0, 0, 0, 463, 466, 1,
		0, 0, 0, 464, 462, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 468, 1, 0, 0,
		0, 466, 464, 1, 0, 0, 0, 467, 469, 5, 46, 0, 0, 468, 467, 1, 0, 0, 0, 468,
		469, 1, 0, 0, 0, 469, 471, 1, 0, 0, 0, 470, 472, 5, 45, 0, 0, 471, 470,
		1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 474, 1, 0, 0, 0, 473, 460, 1, 0,
		0, 0, 473, 474, 1, 0, 0, 0, 474, 488, 1, 0, 0, 0, 475, 479, 3, 28, 14,
		0, 476, 478, 5, 44, 0, 0, 477, 476, 1, 0, 0, 0, 478, 481, 1, 0, 0, 0, 479,
		477, 1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 483, 1, 0, 0, 0, 481, 479,
		1, 0, 0, 0, 482, 484, 5, 46, 0, 0, 483, 482, 1, 0, 0, 0, 483, 484, 1, 0,
		0, 0, 484, 486, 1, 0, 0, 0, 485, 487, 5, 45, 0, 0, 486, 485, 1, 0, 0, 0,
		486, 487, 1, 0, 0, 0, 487, 489, 1, 0, 0, 0, 488, 475, 1, 0, 0, 0, 488,
		489, 1, 0, 0, 0, 489, 506, 1, 0, 0, 0, 490, 492, 3, 82, 41, 0, 491, 493,
		3, 22, 11, 0, 492, 491, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493, 497, 1,
		0, 0, 0, 494, 496, 5, 44, 0, 0, 495, 494, 1, 0, 0, 0, 496, 499, 1, 0, 0,
		0, 497, 495, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 501, 1, 0, 0, 0, 499,
		497, 1, 0, 0, 0, 500, 502, 5, 46, 0, 0, 501, 500, 1, 0, 0, 0, 501, 502,
		1, 0, 0, 0, 502, 504, 1, 0, 0, 0, 503, 505, 5, 45, 0, 0, 504, 503, 1, 0,
		0, 0, 504, 505, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506, 490, 1, 0, 0, 0,
		506, 507, 1, 0, 0, 0, 507, 524, 1, 0, 0, 0, 508, 511, 3, 34, 17, 0, 509,
		511, 3, 36, 18, 0, 510, 508, 1, 0, 0, 0, 510, 509, 1, 0, 0, 0, 511, 515,
		1, 0, 0, 0, 512, 514, 5, 44, 0, 0, 513, 512, 1, 0, 0, 0, 514, 517, 1, 0,
		0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 519, 1, 0, 0, 0,
		517, 515, 1, 0, 0, 0, 518, 520, 5, 46, 0, 0, 519, 518, 1, 0, 0, 0, 519,
		520, 1, 0, 0, 0, 520, 522, 1, 0, 0, 0, 521, 523, 5, 45, 0, 0, 522, 521,
		1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 525, 1, 0, 0, 0, 524, 510, 1, 0,
		0, 0, 524, 525, 1, 0, 0, 0, 525, 539, 1, 0, 0, 0, 526, 530, 3, 38, 19,
		0, 527, 529, 5, 44, 0, 0, 528, 527, 1, 0, 0, 0, 529, 532, 1, 0, 0, 0, 530,
		528, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 534, 1, 0, 0, 0, 532, 530,
		1, 0, 0, 0, 533, 535, 5, 46, 0, 0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 0,
		0, 0, 535, 537, 1, 0, 0, 0, 536, 538, 5, 45, 0, 0, 537, 536, 1, 0, 0, 0,
		537, 538, 1, 0, 0, 0, 538, 540, 1, 0, 0, 0, 539, 526, 1, 0, 0, 0, 539,
		540, 1, 0, 0, 0, 540, 554, 1, 0, 0, 0, 541, 545, 3, 32, 16, 0, 542, 544,
		5, 44, 0, 0, 543, 542, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543, 1, 0,
		0, 0, 545, 546, 1, 0, 0, 0, 546, 549, 1, 0, 0, 0, 547, 545, 1, 0, 0, 0,
		548, 550, 5, 46, 0, 0, 549, 548, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550,
		552, 1, 0, 0, 0, 551, 553, 5, 45, 0, 0, 552, 551, 1, 0, 0, 0, 552, 553,
		1, 0, 0, 0, 553, 555, 1, 0, 0, 0, 554, 541, 1, 0, 0, 0, 554, 555, 1, 0,
		0, 0, 555, 557, 1, 0, 0, 0, 556, 558, 3, 92, 46, 0, 557, 556, 1, 0, 0,
		0, 557, 558, 1, 0, 0, 0, 558, 562, 1, 0, 0, 0, 559, 561, 5, 44, 0, 0, 560,
		559, 1, 0, 0, 0, 561, 564, 1, 0, 0, 0, 562, 560, 1, 0, 0, 0, 562, 563,
		1, 0, 0, 0, 563, 566, 1, 0, 0, 0, 564, 562, 1, 0, 0, 0, 565, 567, 5, 46,
		0, 0, 566, 565, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 569, 1, 0, 0, 0,
		568, 570, 5, 45, 0, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570,
		574, 1, 0, 0, 0, 571, 573, 5, 44, 0, 0, 572, 571, 1, 0, 0, 0, 573, 576,
		1, 0, 0, 0, 574, 572, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 578, 1, 0,
		0, 0, 576, 574, 1, 0, 0, 0, 577, 579, 5, 46, 0, 0, 578, 577, 1, 0, 0, 0,
		578, 579, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 582, 3, 104, 52, 0, 581,
		583, 5, 46, 0, 0, 582, 581, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583, 21,
		1, 0, 0, 0, 584, 585, 5, 11, 0, 0, 585, 23, 1, 0, 0, 0, 586, 587, 5, 30,
		0, 0, 587, 588, 3, 100, 50, 0, 588, 25, 1, 0, 0, 0, 589, 590, 5, 29, 0,
		0, 590, 591, 3, 100, 50, 0, 591, 27, 1, 0, 0, 0, 592, 593, 5, 33, 0, 0,
		593, 594, 3, 100, 50, 0, 594, 29, 1, 0, 0, 0, 595, 596, 5, 41, 0, 0, 596,
		597, 3, 100, 50, 0, 597, 31, 1, 0, 0, 0, 598, 599, 5, 34, 0, 0, 599, 600,
		5, 5, 0, 0, 600, 33, 1, 0, 0, 0, 601, 602, 5, 23, 0, 0, 602, 35, 1, 0,
		0, 0, 603, 604, 5, 25, 0, 0, 604, 37, 1, 0, 0, 0, 605, 606, 5, 22, 0, 0,
		606, 39, 1, 0, 0, 0, 607, 608, 5, 20, 0, 0, 608, 612, 3, 42, 21, 0, 609,
		611, 5, 44, 0, 0, 610, 609, 1, 0, 0, 0, 611, 614, 1, 0, 0, 0, 612, 610,
		1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 615, 1, 0, 0, 0, 614, 612, 1, 0,
		0, 0, 615, 616, 7, 0, 0, 0, 616, 618, 1, 0, 0, 0, 617, 607, 1, 0, 0, 0,
		618, 619, 1, 0, 0, 0, 619, 617, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620,
		41, 1, 0, 0, 0, 621, 625, 3, 102, 51, 0, 622, 624, 5, 44, 0, 0, 623, 622,
		1, 0, 0, 0, 624, 627, 1, 0, 0, 0, 625, 623, 1, 0, 0, 0, 625, 626, 1, 0,
		0, 0, 626, 629, 1, 0, 0, 0, 627, 625, 1, 0, 0, 0, 628, 630, 5, 46, 0, 0,
		629, 628, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630, 632, 1, 0, 0, 0, 631,
		633, 5, 45, 0, 0, 632, 631, 1, 0, 0, 0, 632, 633, 1, 0, 0, 0, 633, 637,
		1, 0, 0, 0, 634, 636, 5, 44, 0, 0, 635, 634, 1, 0, 0, 0, 636, 639, 1, 0,
		0, 0, 637, 635, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 640, 1, 0, 0, 0,
		639, 637, 1, 0, 0, 0, 640, 644, 3, 106, 53, 0, 641, 643, 5, 44, 0, 0, 642,
		641, 1, 0, 0, 0, 643, 646, 1, 0, 0, 0, 644, 642, 1, 0, 0, 0, 644, 645,
		1, 0, 0, 0, 645, 648, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0, 647, 649, 5, 46,
		0, 0, 648, 647, 1, 0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 651, 1, 0, 0, 0,
		650, 652, 5, 45, 0, 0, 651, 650, 1, 0, 0, 0, 651, 652, 1, 0, 0, 0, 652,
		666, 1, 0, 0, 0, 653, 657, 3, 90, 45, 0, 654, 656, 5, 44, 0, 0, 655, 654,
		1, 0, 0, 0, 656, 659, 1, 0, 0, 0, 657, 655, 1, 0, 0, 0, 657, 658, 1, 0,
		0, 0, 658, 661, 1, 0, 0, 0, 659, 657, 1, 0, 0, 0, 660, 662, 5, 46, 0, 0,
		661, 660, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 664, 1, 0, 0, 0, 663,
		665, 5, 45, 0, 0, 664, 663, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 667,
		1, 0, 0, 0, 666, 653, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 681, 1, 0,
		0, 0, 668, 672, 3, 88, 44, 0, 669, 671, 5, 44, 0, 0, 670, 669, 1, 0, 0,
		0, 671, 674, 1, 0, 0, 0, 672, 670, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673,
		676, 1, 0, 0, 0, 674, 672, 1, 0, 0, 0, 675, 677, 5, 46, 0, 0, 676, 675,
		1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 679, 1, 0, 0, 0, 678, 680, 5, 45,
		0, 0, 679, 678, 1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 682, 1, 0, 0, 0,
		681, 668, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 696, 1, 0, 0, 0, 683,
		687, 3, 80, 40, 0, 684, 686, 5, 44, 0, 0, 685, 684, 1, 0, 0, 0, 686, 689,
		1, 0, 0, 0, 687, 685, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 691, 1, 0,
		0, 0, 689, 687, 1, 0, 0, 0, 690, 692, 5, 46, 0, 0, 691, 690, 1, 0, 0, 0,
		691, 692, 1, 0, 0, 0, 692, 694, 1, 0, 0, 0, 693, 695, 5, 45, 0, 0, 694,
		693, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695, 697, 1, 0, 0, 0, 696, 683,
		1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 711, 1, 0, 0, 0, 698, 702, 3, 82,
		41, 0, 699, 701, 5, 44, 0, 0, 700, 699, 1, 0, 0, 0, 701, 704, 1, 0, 0,
		0, 702, 700, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 706, 1, 0, 0, 0, 704,
		702, 1, 0, 0, 0, 705, 707, 5, 46, 0, 0, 706, 705, 1, 0, 0, 0, 706, 707,
		1, 0, 0, 0, 707, 709, 1, 0, 0, 0, 708, 710, 5, 45, 0, 0, 709, 708, 1, 0,
		0, 0, 709, 710, 1, 0, 0, 0, 710, 712, 1, 0, 0, 0, 711, 698, 1, 0, 0, 0,
		711, 712, 1, 0, 0, 0, 712, 714, 1, 0, 0, 0, 713, 715, 3, 92, 46, 0, 714,
		713, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 719, 1, 0, 0, 0, 716, 718,
		5, 44, 0, 0, 717, 716, 1, 0, 0, 0, 718, 721, 1, 0, 0, 0, 719, 717, 1, 0,
		0, 0, 719, 720, 1, 0, 0, 0, 720, 723, 1, 0, 0, 0, 721, 719, 1, 0, 0, 0,
		722, 724, 5, 46, 0, 0, 723, 722, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724,
		726, 1, 0, 0, 0, 725, 727, 5, 45, 0, 0, 726, 725, 1, 0, 0, 0, 726, 727,
		1, 0, 0, 0, 727, 731, 1, 0, 0, 0, 728, 730, 5, 44, 0, 0, 729, 728, 1, 0,
		0, 0, 730, 733, 1, 0, 0, 0, 731, 729, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0,
		732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 734, 736, 5, 46, 0, 0, 735,
		734, 1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 739,
		3, 104, 52, 0, 738, 740, 5, 46, 0, 0, 739, 738, 1, 0, 0, 0, 739, 740, 1,
		0, 0, 0, 740, 43, 1, 0, 0, 0, 741, 742, 5, 21, 0, 0, 742, 746, 3, 46, 23,
		0, 743, 745, 5, 44, 0, 0, 744, 743, 1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 746,
		744, 1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 749, 1, 0, 0, 0, 748, 746,
		1, 0, 0, 0, 749, 750, 7, 0, 0, 0, 750, 752, 1, 0, 0, 0, 751, 741, 1, 0,
		0, 0, 752, 753, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0,
		754, 45, 1, 0, 0, 0, 755, 759, 3, 102, 51, 0, 756, 758, 5, 44, 0, 0, 757,
		756, 1, 0, 0, 0, 758, 761, 1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 759, 760,
		1, 0, 0, 0, 760, 763, 1, 0, 0, 0, 761, 759, 1, 0, 0, 0, 762, 764, 5, 46,
		0, 0, 763, 762, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 766, 1, 0, 0, 0,
		765, 767, 5, 45, 0, 0, 766, 765, 1, 0, 0, 0, 766, 767, 1, 0, 0, 0, 767,
		771, 1, 0, 0, 0, 768, 770, 5, 44, 0, 0, 769, 768, 1, 0, 0, 0, 770, 773,
		1, 0, 0, 0, 771, 769, 1, 0, 0, 0, 771, 772, 1, 0, 0, 0, 772, 774, 1, 0,
		0, 0, 773, 771, 1, 0, 0, 0, 774, 778, 3, 106, 53, 0, 775, 777, 5, 44, 0,
		0, 776, 775, 1, 0, 0, 0, 777, 780, 1, 0, 0, 0, 778, 776, 1, 0, 0, 0, 778,
		779, 1, 0, 0, 0, 779, 782, 1, 0, 0, 0, 780, 778, 1, 0, 0, 0, 781, 783,
		5, 46, 0, 0, 782, 781, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 785, 1, 0,
		0, 0, 784, 786, 5, 45, 0, 0, 785, 784, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0,
		786, 800, 1, 0, 0, 0, 787, 791, 3, 90, 45, 0, 788, 790, 5, 44, 0, 0, 789,
		788, 1, 0, 0, 0, 790, 793, 1, 0, 0, 0, 791, 789, 1, 0, 0, 0, 791, 792,
		1, 0, 0, 0, 792, 795, 1, 0, 0, 0, 793, 791, 1, 0, 0, 0, 794, 796, 5, 46,
		0, 0, 795, 794, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 798, 1, 0, 0, 0,
		797, 799, 5, 45, 0, 0, 798, 797, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799,
		801, 1, 0, 0, 0, 800, 787, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 815,
		1, 0, 0, 0, 802, 806, 3, 88, 44, 0, 803, 805, 5, 44, 0, 0, 804, 803, 1,
		0, 0, 0, 805, 808, 1, 0, 0, 0, 806, 804, 1, 0, 0, 0, 806, 807, 1, 0, 0,
		0, 807, 810, 1, 0, 0, 0, 808, 806, 1, 0, 0, 0, 809, 811, 5, 46, 0, 0, 810,
		809, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 813, 1, 0, 0, 0, 812, 814,
		5, 45, 0, 0, 813, 812, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 816, 1, 0,
		0, 0, 815, 802, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 830, 1, 0, 0, 0,
		817, 821, 3, 80, 40, 0, 818, 820, 5, 44, 0, 0, 819, 818, 1, 0, 0, 0, 820,
		823, 1, 0, 0, 0, 821, 819, 1, 0, 0, 0, 821, 822, 1, 0, 0, 0, 822, 825,
		1, 0, 0, 0, 823, 821, 1, 0, 0, 0, 824, 826, 5, 46, 0, 0, 825, 824, 1, 0,
		0, 0, 825, 826, 1, 0, 0, 0, 826, 828, 1, 0, 0, 0, 827, 829, 5, 45, 0, 0,
		828, 827, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0, 0, 0, 830,
		817, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 845, 1, 0, 0, 0, 832, 836,
		3, 48, 24, 0, 833, 835, 5, 44, 0, 0, 834, 833, 1, 0, 0, 0, 835, 838, 1,
		0, 0, 0, 836, 834, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 840, 1, 0, 0,
		0, 838, 836, 1, 0, 0, 0, 839, 841, 5, 46, 0, 0, 840, 839, 1, 0, 0, 0, 840,
		841, 1, 0, 0, 0, 841, 843, 1, 0, 0, 0, 842, 844, 5, 45, 0, 0, 843, 842,
		1, 0, 0, 0, 843, 844, 1, 0, 0, 0, 844, 846, 1, 0, 0, 0, 845, 832, 1, 0,
		0, 0, 845, 846, 1, 0, 0, 0, 846, 848, 1, 0, 0, 0, 847, 849, 3, 92, 46,
		0, 848, 847, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 853, 1, 0, 0, 0, 850,
		852, 5, 44, 0, 0, 851, 850, 1, 0, 0, 0, 852, 855, 1, 0, 0, 0, 853, 851,
		1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 857, 1, 0, 0, 0, 855, 853, 1, 0,
		0, 0, 856, 858, 5, 46, 0, 0, 857, 856, 1, 0, 0, 0, 857, 858, 1, 0, 0, 0,
		858, 860, 1, 0, 0, 0, 859, 861, 5, 45, 0, 0, 860, 859, 1, 0, 0, 0, 860,
		861, 1, 0, 0, 0, 861, 865, 1, 0, 0, 0, 862, 864, 5, 44, 0, 0, 863, 862,
		1, 0, 0, 0, 864, 867, 1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0,
		0, 0, 866, 869, 1, 0, 0, 0, 867, 865, 1, 0, 0, 0, 868, 870, 5, 46, 0, 0,
		869, 868, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871,
		873, 3, 104, 52, 0, 872, 874, 5, 46, 0, 0, 873, 872, 1, 0, 0, 0, 873, 874,
		1, 0, 0, 0, 874, 47, 1, 0, 0, 0, 875, 878, 5, 31, 0, 0, 876, 879, 3, 100,
		50, 0, 877, 879, 3, 96, 48, 0, 878, 876, 1, 0, 0, 0, 878, 877, 1, 0, 0,
		0, 879, 49, 1, 0, 0, 0, 880, 881, 5, 19, 0, 0, 881, 885, 3, 52, 26, 0,
		882, 884, 5, 44, 0, 0, 883, 882, 1, 0, 0, 0, 884, 887, 1, 0, 0, 0, 885,
		883, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 888, 1, 0, 0, 0, 887, 885,
		1, 0, 0, 0, 888, 889, 7, 0, 0, 0, 889, 891, 1, 0, 0, 0, 890, 880, 1, 0,
		0, 0, 891, 892, 1, 0, 0, 0, 892, 890, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0,
		893, 51, 1, 0, 0, 0, 894, 898, 3, 102, 51, 0, 895, 897, 5, 44, 0, 0, 896,
		895, 1, 0, 0, 0, 897, 900, 1, 0, 0, 0, 898, 896, 1, 0, 0, 0, 898, 899,
		1, 0, 0, 0, 899, 902, 1, 0, 0, 0, 900, 898, 1, 0, 0, 0, 901, 903, 5, 46,
		0, 0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903, 905, 1, 0, 0, 0,
		904, 906, 5, 45, 0, 0, 905, 904, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 906,
		910, 1, 0, 0, 0, 907, 909, 5, 44, 0, 0, 908, 907, 1, 0, 0, 0, 909, 912,
		1, 0, 0, 0, 910, 908, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 913, 1, 0,
		0, 0, 912, 910, 1, 0, 0, 0, 913, 917, 3, 106, 53, 0, 914, 916, 5, 44, 0,
		0, 915, 914, 1, 0, 0, 0, 916, 919, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 917,
		918, 1, 0, 0, 0, 918, 921, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 920, 922,
		5, 46, 0, 0, 921, 920, 1, 0, 0, 0, 921, 922, 1, 0, 0, 0, 922, 924, 1, 0,
		0, 0, 923, 925, 5, 45, 0, 0, 924, 923, 1, 0, 0, 0, 924, 925, 1, 0, 0, 0,
		925, 939, 1, 0, 0, 0, 926, 930, 3, 88, 44, 0, 927, 929, 5, 44, 0, 0, 928,
		927, 1, 0, 0, 0, 929, 932, 1, 0, 0, 0, 930, 928, 1, 0, 0, 0, 930, 931,
		1, 0, 0, 0, 931, 934, 1, 0, 0, 0, 932, 930, 1, 0, 0, 0, 933, 935, 5, 46,
		0, 0, 934, 933, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 937, 1, 0, 0, 0,
		936, 938, 5, 45, 0, 0, 937, 936, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938,
		940, 1, 0, 0, 0, 939, 926, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 942,
		1, 0, 0, 0, 941, 943, 3, 92, 46, 0, 942, 941, 1, 0, 0, 0, 942, 943, 1,
		0, 0, 0, 943, 947, 1, 0, 0, 0, 944, 946, 5, 44, 0, 0, 945, 944, 1, 0, 0,
		0, 946, 949, 1, 0, 0, 0, 947, 945, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948,
		951, 1, 0, 0, 0, 949, 947, 1, 0, 0, 0, 950, 952, 5, 46, 0, 0, 951, 950,
		1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952, 954, 1, 0, 0, 0, 953, 955, 5, 45,
		0, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 959, 1, 0, 0, 0,
		956, 958, 5, 44, 0, 0, 957, 956, 1, 0, 0, 0, 958, 961, 1, 0, 0, 0, 959,
		957, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 963, 1, 0, 0, 0, 961, 959,
		1, 0, 0, 0, 962, 964, 5, 46, 0, 0, 963, 962, 1, 0, 0, 0, 963, 964, 1, 0,
		0, 0, 964, 965, 1, 0, 0, 0, 965, 967, 3, 104, 52, 0, 966, 968, 5, 46, 0,
		0, 967, 966, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 53, 1, 0, 0, 0, 969,
		970, 5, 15, 0, 0, 970, 974, 3, 56, 28, 0, 971, 973, 5, 44, 0, 0, 972, 971,
		1, 0, 0, 0, 973, 976, 1, 0, 0, 0, 974, 972, 1, 0, 0, 0, 974, 975, 1, 0,
		0, 0, 975, 977, 1, 0, 0, 0, 976, 974, 1, 0, 0, 0, 977, 978, 7, 0, 0, 0,
		978, 980, 1, 0, 0, 0, 979, 969, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981,
		979, 1, 0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 55, 1, 0, 0, 0, 983, 987, 3,
		102, 51, 0, 984, 986, 5, 44, 0, 0, 985, 984, 1, 0, 0, 0, 986, 989, 1, 0,
		0, 0, 987, 985, 1, 0, 0, 0, 987, 988, 1, 0, 0, 0, 988, 991, 1, 0, 0, 0,
		989, 987, 1, 0, 0, 0, 990, 992, 5, 46, 0, 0, 991, 990, 1, 0, 0, 0, 991,
		992, 1, 0, 0, 0, 992, 994, 1, 0, 0, 0, 993, 995, 5, 45, 0, 0, 994, 993,
		1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 999, 1, 0, 0, 0, 996, 998, 5, 44,
		0, 0, 997, 996, 1, 0, 0, 0, 998, 1001, 1, 0, 0, 0, 999, 997, 1, 0, 0, 0,
		999, 1000, 1, 0, 0, 0, 1000, 1002, 1, 0, 0, 0, 1001, 999, 1, 0, 0, 0, 1002,
		1006, 3, 106, 53, 0, 1003, 1005, 5, 44, 0, 0, 1004, 1003, 1, 0, 0, 0, 1005,
		1008, 1, 0, 0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007,
		1010, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1009, 1011, 5, 46, 0, 0, 1010,
		1009, 1, 0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1013, 1, 0, 0, 0, 1012,
		1014, 5, 45, 0, 0, 1013, 1012, 1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014,
		1028, 1, 0, 0, 0, 1015, 1019, 3, 90, 45, 0, 1016, 1018, 5, 44, 0, 0, 1017,
		1016, 1, 0, 0, 0, 1018, 1021, 1, 0, 0, 0, 1019, 1017, 1, 0, 0, 0, 1019,
		1020, 1, 0, 0, 0, 1020, 1023, 1, 0, 0, 0, 1021, 1019, 1, 0, 0, 0, 1022,
		1024, 5, 46, 0, 0, 1023, 1022, 1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024,
		1026, 1, 0, 0, 0, 1025, 1027, 5, 45, 0, 0, 1026, 1025, 1, 0, 0, 0, 1026,
		1027, 1, 0, 0, 0, 1027, 1029, 1, 0, 0, 0, 1028, 1015, 1, 0, 0, 0, 1028,
		1029, 1, 0, 0, 0, 1029, 1043, 1, 0, 0, 0, 1030, 1034, 3, 88, 44, 0, 1031,
		1033, 5, 44, 0, 0, 1032, 1031, 1, 0, 0, 0, 1033, 1036, 1, 0, 0, 0, 1034,
		1032, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1038, 1, 0, 0, 0, 1036,
		1034, 1, 0, 0, 0, 1037, 1039, 5, 46, 0, 0, 1038, 1037, 1, 0, 0, 0, 1038,
		1039, 1, 0, 0, 0, 1039, 1041, 1, 0, 0, 0, 1040, 1042, 5, 45, 0, 0, 1041,
		1040, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1044, 1, 0, 0, 0, 1043,
		1030, 1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0, 1044, 1058, 1, 0, 0, 0, 1045,
		1049, 3, 80, 40, 0, 1046, 1048, 5, 44, 0, 0, 1047, 1046, 1, 0, 0, 0, 1048,
		1051, 1, 0, 0, 0, 1049, 1047, 1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050,
		1053, 1, 0, 0, 0, 1051, 1049, 1, 0, 0, 0, 1052, 1054, 5, 46, 0, 0, 1053,
		1052, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1056, 1, 0, 0, 0, 1055,
		1057, 5, 45, 0, 0, 1056, 1055, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057,
		1059, 1, 0, 0, 0, 1058, 1045, 1, 0, 0, 0, 1058, 1059, 1, 0, 0, 0, 1059,
		1073, 1, 0, 0, 0, 1060, 1064, 3, 60, 30, 0, 1061, 1063, 5, 44, 0, 0, 1062,
		1061, 1, 0, 0, 0, 1063, 1066, 1, 0, 0, 0, 1064, 1062, 1, 0, 0, 0, 1064,
		1065, 1, 0, 0, 0, 1065, 1068, 1, 0, 0, 0, 1066, 1064, 1, 0, 0, 0, 1067,
		1069, 5, 46, 0, 0, 1068, 1067, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069,
		1071, 1, 0, 0, 0, 1070, 1072, 5, 45, 0, 0, 1071, 1070, 1, 0, 0, 0, 1071,
		1072, 1, 0, 0, 0, 1072, 1074, 1, 0, 0, 0, 1073, 1060, 1, 0, 0, 0, 1073,
		1074, 1, 0, 0, 0, 1074, 1088, 1, 0, 0, 0, 1075, 1079, 3, 84, 42, 0, 1076,
		1078, 5, 44, 0, 0, 1077, 1076, 1, 0, 0, 0, 1078, 1081, 1, 0, 0, 0, 1079,
		1077, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1083, 1, 0, 0, 0, 1081,
		1079, 1, 0, 0, 0, 1082, 1084, 5, 46, 0, 0, 1083, 1082, 1, 0, 0, 0, 1083,
		1084, 1, 0, 0, 0, 1084, 1086, 1, 0, 0, 0, 1085, 1087, 5, 45, 0, 0, 1086,
		1085, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087, 1089, 1, 0, 0, 0, 1088,
		1075, 1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 1103, 1, 0, 0, 0, 1090,
		1094, 3, 86, 43, 0, 1091, 1093, 5, 44, 0, 0, 1092, 1091, 1, 0, 0, 0, 1093,
		1096, 1, 0, 0, 0, 1094, 1092, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095,
		1098, 1, 0, 0, 0, 1096, 1094, 1, 0, 0, 0, 1097, 1099, 5, 46, 0, 0, 1098,
		1097, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100,
		1102, 5, 45, 0, 0, 1101, 1100, 1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102,
		1104, 1, 0, 0, 0, 1103, 1090, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104,
		1118, 1, 0, 0, 0, 1105, 1109, 3, 58, 29, 0, 1106, 1108, 5, 44, 0, 0, 1107,
		1106, 1, 0, 0, 0, 1108, 1111, 1, 0, 0, 0, 1109, 1107, 1, 0, 0, 0, 1109,
		1110, 1, 0, 0, 0, 1110, 1113, 1, 0, 0, 0, 1111, 1109, 1, 0, 0, 0, 1112,
		1114, 5, 46, 0, 0, 1113, 1112, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114,
		1116, 1, 0, 0, 0, 1115, 1117, 5, 45, 0, 0, 1116, 1115, 1, 0, 0, 0, 1116,
		1117, 1, 0, 0, 0, 1117, 1119, 1, 0, 0, 0, 1118, 1105, 1, 0, 0, 0, 1118,
		1119, 1, 0, 0, 0, 1119, 1121, 1, 0, 0, 0, 1120, 1122, 3, 92, 46, 0, 1121,
		1120, 1, 0, 0, 0, 1121, 1122, 1, 0, 0, 0, 1122, 1126, 1, 0, 0, 0, 1123,
		1125, 5, 44, 0, 0, 1124, 1123, 1, 0, 0, 0, 1125, 1128, 1, 0, 0, 0, 1126,
		1124, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1130, 1, 0, 0, 0, 1128,
		1126, 1, 0, 0, 0, 1129, 1131, 5, 46, 0, 0, 1130, 1129, 1, 0, 0, 0, 1130,
		1131, 1, 0, 0, 0, 1131, 1133, 1, 0, 0, 0, 1132, 1134, 5, 45, 0, 0, 1133,
		1132, 1, 0, 0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 1138, 1, 0, 0, 0, 1135,
		1137, 5, 44, 0, 0, 1136, 1135, 1, 0, 0, 0, 1137, 1140, 1, 0, 0, 0, 1138,
		1136, 1, 0, 0, 0, 1138, 1139, 1, 0, 0, 0, 1139, 1142, 1, 0, 0, 0, 1140,
		1138, 1, 0, 0, 0, 1141, 1143, 5, 46, 0, 0, 1142, 1141, 1, 0, 0, 0, 1142,
		1143, 1, 0, 0, 0, 1143, 1144, 1, 0, 0, 0, 1144, 1145, 3, 104, 52, 0, 1145,
		57, 1, 0, 0, 0, 1146, 1149, 5, 40, 0, 0, 1147, 1150, 3, 100, 50, 0, 1148,
		1150, 3, 96, 48, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1148, 1, 0, 0, 0, 1150,
		59, 1, 0, 0, 0, 1151, 1154, 5, 42, 0, 0, 1152, 1155, 3, 100, 50, 0, 1153,
		1155, 3, 96, 48, 0, 1154, 1152, 1, 0, 0, 0, 1154, 1153, 1, 0, 0, 0, 1155,
		61, 1, 0, 0, 0, 1156, 1157, 5, 14, 0, 0, 1157, 1161, 3, 64, 32, 0, 1158,
		1160, 5, 44, 0, 0, 1159, 1158, 1, 0, 0, 0, 1160, 1163, 1, 0, 0, 0, 1161,
		1159, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1164, 1, 0, 0, 0, 1163,
		1161, 1, 0, 0, 0, 1164, 1165, 7, 0, 0, 0, 1165, 1167, 1, 0, 0, 0, 1166,
		1156, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1166, 1, 0, 0, 0, 1168,
		1169, 1, 0, 0, 0, 1169, 63, 1, 0, 0, 0, 1170, 1174, 3, 102, 51, 0, 1171,
		1173, 5, 44, 0, 0, 1172, 1171, 1, 0, 0, 0, 1173, 1176, 1, 0, 0, 0, 1174,
		1172, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175, 1178, 1, 0, 0, 0, 1176,
		1174, 1, 0, 0, 0, 1177, 1179, 5, 46, 0, 0, 1178, 1177, 1, 0, 0, 0, 1178,
		1179, 1, 0, 0, 0, 1179, 1181, 1, 0, 0, 0, 1180, 1182, 5, 45, 0, 0, 1181,
		1180, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182, 1186, 1, 0, 0, 0, 1183,
		1185, 5, 44, 0, 0, 1184, 1183, 1, 0, 0, 0, 1185, 1188, 1, 0, 0, 0, 1186,
		1184, 1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1189, 1, 0, 0, 0, 1188,
		1186, 1, 0, 0, 0, 1189, 1193, 3, 70, 35, 0, 1190, 1192, 5, 44, 0, 0, 1191,
		1190, 1, 0, 0, 0, 1192, 1195, 1, 0, 0, 0, 1193, 1191, 1, 0, 0, 0, 1193,
		1194, 1, 0, 0, 0, 1194, 1197, 1, 0, 0, 0, 1195, 1193, 1, 0, 0, 0, 1196,
		1198, 5, 46, 0, 0, 1197, 1196, 1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0, 1198,
		1200, 1, 0, 0, 0, 1199, 1201, 5, 45, 0, 0, 1200, 1199, 1, 0, 0, 0, 1200,
		1201, 1, 0, 0, 0, 1201, 1215, 1, 0, 0, 0, 1202, 1206, 3, 90, 45, 0, 1203,
		1205, 5, 44, 0, 0, 1204, 1203, 1, 0, 0, 0, 1205, 1208, 1, 0, 0, 0, 1206,
		1204, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1210, 1, 0, 0, 0, 1208,
		1206, 1, 0, 0, 0, 1209, 1211, 5, 46, 0, 0, 1210, 1209, 1, 0, 0, 0, 1210,
		1211, 1, 0, 0, 0, 1211, 1213, 1, 0, 0, 0, 1212, 1214, 5, 45, 0, 0, 1213,
		1212, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214, 1216, 1, 0, 0, 0, 1215,
		1202, 1, 0, 0, 0, 1215, 1216, 1, 0, 0, 0, 1216, 1230, 1, 0, 0, 0, 1217,
		1221, 3, 88, 44, 0, 1218, 1220, 5, 44, 0, 0, 1219, 1218, 1, 0, 0, 0, 1220,
		1223, 1, 0, 0, 0, 1221, 1219, 1, 0, 0, 0, 1221, 1222, 1, 0, 0, 0, 1222,
		1225, 1, 0, 0, 0, 1223, 1221, 1, 0, 0, 0, 1224, 1226, 5, 46, 0, 0, 1225,
		1224, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1228, 1, 0, 0, 0, 1227,
		1229, 5, 45, 0, 0, 1228, 1227, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229,
		1231, 1, 0, 0, 0, 1230, 1217, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231,
		1245, 1, 0, 0, 0, 1232, 1236, 3, 80, 40, 0, 1233, 1235, 5, 44, 0, 0, 1234,
		1233, 1, 0, 0, 0, 1235, 1238, 1, 0, 0, 0, 1236, 1234, 1, 0, 0, 0, 1236,
		1237, 1, 0, 0, 0, 1237, 1240, 1, 0, 0, 0, 1238, 1236, 1, 0, 0, 0, 1239,
		1241, 5, 46, 0, 0, 1240, 1239, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241,
		1243, 1, 0, 0, 0, 1242, 1244, 5, 45, 0, 0, 1243, 1242, 1, 0, 0, 0, 1243,
		1244, 1, 0, 0, 0, 1244, 1246, 1, 0, 0, 0, 1245, 1232, 1, 0, 0, 0, 1245,
		1246, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247, 1251, 3, 72, 36, 0, 1248,
		1250, 5, 44, 0, 0, 1249, 1248, 1, 0, 0, 0, 1250, 1253, 1, 0, 0, 0, 1251,
		1249, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 1255, 1, 0, 0, 0, 1253,
		1251, 1, 0, 0, 0, 1254, 1256, 5, 46, 0, 0, 1255, 1254, 1, 0, 0, 0, 1255,
		1256, 1, 0, 0, 0, 1256, 1258, 1, 0, 0, 0, 1257, 1259, 5, 45, 0, 0, 1258,
		1257, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1273, 1, 0, 0, 0, 1260,
		1264, 3, 68, 34, 0, 1261, 1263, 5, 44, 0, 0, 1262, 1261, 1, 0, 0, 0, 1263,
		1266, 1, 0, 0, 0, 1264, 1262, 1, 0, 0, 0, 1264, 1265, 1, 0, 0, 0, 1265,
		1268, 1, 0, 0, 0, 1266, 1264, 1, 0, 0, 0, 1267, 1269, 5, 46, 0, 0, 1268,
		1267, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1271, 1, 0, 0, 0, 1270,
		1272, 5, 45, 0, 0, 1271, 1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272,
		1274, 1, 0, 0, 0, 1273, 1260, 1, 0, 0, 0, 1273, 1274, 1, 0, 0, 0, 1274,
		1276, 1, 0, 0, 0, 1275, 1277, 3, 92, 46, 0, 1276, 1275, 1, 0, 0, 0, 1276,
		1277, 1, 0, 0, 0, 1277, 1281, 1, 0, 0, 0, 1278, 1280, 5, 44, 0, 0, 1279,
		1278, 1, 0, 0, 0, 1280, 1283, 1, 0, 0, 0, 1281, 1279, 1, 0, 0, 0, 1281,
		1282, 1, 0, 0, 0, 1282, 1285, 1, 0, 0, 0, 1283, 1281, 1, 0, 0, 0, 1284,
		1286, 5, 46, 0, 0, 1285, 1284, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286,
		1288, 1, 0, 0, 0, 1287, 1289, 5, 45, 0, 0, 1288, 1287, 1, 0, 0, 0, 1288,
		1289, 1, 0, 0, 0, 1289, 1293, 1, 0, 0, 0, 1290, 1292, 5, 44, 0, 0, 1291,
		1290, 1, 0, 0, 0, 1292, 1295, 1, 0, 0, 0, 1293, 1291, 1, 0, 0, 0, 1293,
		1294, 1, 0, 0, 0, 1294, 1297, 1, 0, 0, 0, 1295, 1293, 1, 0, 0, 0, 1296,
		1298, 5, 46, 0, 0, 1297, 1296, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298,
		1299, 1, 0, 0, 0, 1299, 1301, 3, 104, 52, 0, 1300, 1302, 5, 46, 0, 0, 1301,
		1300, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 65, 1, 0, 0, 0, 1303, 1307,
		3, 102, 51, 0, 1304, 1306, 5, 44, 0, 0, 1305, 1304, 1, 0, 0, 0, 1306, 1309,
		1, 0, 0, 0, 1307, 1305, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308, 1311,
		1, 0, 0, 0, 1309, 1307, 1, 0, 0, 0, 1310, 1312, 5, 46, 0, 0, 1311, 1310,
		1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1314, 1, 0, 0, 0, 1313, 1315,
		5, 45, 0, 0, 1314, 1313, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315, 1319,
		1, 0, 0, 0, 1316, 1318, 5, 44, 0, 0, 1317, 1316, 1, 0, 0, 0, 1318, 1321,
		1, 0, 0, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1323,
		1, 0, 0, 0, 1321, 1319, 1, 0, 0, 0, 1322, 1324, 5, 46, 0, 0, 1323, 1322,
		1, 0, 0, 0, 1323, 1324, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1329,
		3, 70, 35, 0, 1326, 1328, 5, 44, 0, 0, 1327, 1326, 1, 0, 0, 0, 1328, 1331,
		1, 0, 0, 0, 1329, 1327, 1, 0, 0, 0, 1329, 1330, 1, 0, 0, 0, 1330, 1333,
		1, 0, 0, 0, 1331, 1329, 1, 0, 0, 0, 1332, 1334, 5, 46, 0, 0, 1333, 1332,
		1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334, 1336, 1, 0, 0, 0, 1335, 1337,
		5, 45, 0, 0, 1336, 1335, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337, 1346,
		1, 0, 0, 0, 1338, 1340, 5, 44, 0, 0, 1339, 1338, 1, 0, 0, 0, 1340, 1341,
		1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 1343,
		1, 0, 0, 0, 1343, 1345, 3, 70, 35, 0, 1344, 1339, 1, 0, 0, 0, 1345, 1348,
		1, 0, 0, 0, 1346, 1344, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1352,
		1, 0, 0, 0, 1348, 1346, 1, 0, 0, 0, 1349, 1351, 5, 44, 0, 0, 1350, 1349,
		1, 0, 0, 0, 1351, 1354, 1, 0, 0, 0, 1352, 1350, 1, 0, 0, 0, 1352, 1353,
		1, 0, 0, 0, 1353, 1356, 1, 0, 0, 0, 1354, 1352, 1, 0, 0, 0, 1355, 1357,
		5, 46, 0, 0, 1356, 1355, 1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 1359,
		1, 0, 0, 0, 1358, 1360, 5, 45, 0, 0, 1359, 1358, 1, 0, 0, 0, 1359, 1360,
		1, 0, 0, 0, 1360, 1364, 1, 0, 0, 0, 1361, 1363, 5, 44, 0, 0, 1362, 1361,
		1, 0, 0, 0, 1363, 1366, 1, 0, 0, 0, 1364, 1362, 1, 0, 0, 0, 1364, 1365,
		1, 0, 0, 0, 1365, 1367, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1371,
		3, 104, 52, 0, 1368, 1370, 5, 44, 0, 0, 1369, 1368, 1, 0, 0, 0, 1370, 1373,
		1, 0, 0, 0, 1371, 1369, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 1375,
		1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1374, 1376, 5, 46, 0, 0, 1375, 1374,
		1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 67, 1, 0, 0, 0, 1377, 1380, 5,
		41, 0, 0, 1378, 1381, 3, 70, 35, 0, 1379, 1381, 3, 66, 33, 0, 1380, 1378,
		1, 0, 0, 0, 1380, 1379, 1, 0, 0, 0, 1381, 69, 1, 0, 0, 0, 1382, 1383, 3,
		114, 57, 0, 1383, 71, 1, 0, 0, 0, 1384, 1385, 5, 37, 0, 0, 1385, 1386,
		3, 100, 50, 0, 1386, 73, 1, 0, 0, 0, 1387, 1388, 5, 16, 0, 0, 1388, 1392,
		3, 76, 38, 0, 1389, 1391, 5, 44, 0, 0, 1390, 1389, 1, 0, 0, 0, 1391, 1394,
		1, 0, 0, 0, 1392, 1390, 1, 0, 0, 0, 1392, 1393, 1, 0, 0, 0, 1393, 1395,
		1, 0, 0, 0, 1394, 1392, 1, 0, 0, 0, 1395, 1396, 7, 0, 0, 0, 1396, 1398,
		1, 0, 0, 0, 1397, 1387, 1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1397,
		1, 0, 0, 0, 1399, 1400, 1, 0, 0, 0, 1400, 75, 1, 0, 0, 0, 1401, 1405, 3,
		102, 51, 0, 1402, 1404, 5, 44, 0, 0, 1403, 1402, 1, 0, 0, 0, 1404, 1407,
		1, 0, 0, 0, 1405, 1403, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406, 1409,
		1, 0, 0, 0, 1407, 1405, 1, 0, 0, 0, 1408, 1410, 5, 46, 0, 0, 1409, 1408,
		1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1412, 1, 0, 0, 0, 1411, 1413,
		5, 45, 0, 0, 1412, 1411, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413, 1417,
		1, 0, 0, 0, 1414, 1416, 5, 44, 0, 0, 1415, 1414, 1, 0, 0, 0, 1416, 1419,
		1, 0, 0, 0, 1417, 1415, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1420,
		1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1420, 1424, 3, 106, 53, 0, 1421, 1423,
		5, 44, 0, 0, 1422, 1421, 1, 0, 0, 0, 1423, 1426, 1, 0, 0, 0, 1424, 1422,
		1, 0, 0, 0, 1424, 1425, 1, 0, 0, 0, 1425, 1428, 1, 0, 0, 0, 1426, 1424,
		1, 0, 0, 0, 1427, 1429, 5, 46, 0, 0, 1428, 1427, 1, 0, 0, 0, 1428, 1429,
		1, 0, 0, 0, 1429, 1431, 1, 0, 0, 0, 1430, 1432, 5, 45, 0, 0, 1431, 1430,
		1, 0, 0, 0, 1431, 1432, 1, 0, 0, 0, 1432, 1446, 1, 0, 0, 0, 1433, 1437,
		3, 90, 45, 0, 1434, 1436, 5, 44, 0, 0, 1435, 1434, 1, 0, 0, 0, 1436, 1439,
		1, 0, 0, 0, 1437, 1435, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1441,
		1, 0, 0, 0, 1439, 1437, 1, 0, 0, 0, 1440, 1442, 5, 46, 0, 0, 1441, 1440,
		1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1444, 1, 0, 0, 0, 1443, 1445,
		5, 45, 0, 0, 1444, 1443, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0, 1445, 1447,
		1, 0, 0, 0, 1446, 1433, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1461,
		1, 0, 0, 0, 1448, 1452, 3, 88, 44, 0, 1449, 1451, 5, 44, 0, 0, 1450, 1449,
		1, 0, 0, 0, 1451, 1454, 1, 0, 0, 0, 1452, 1450, 1, 0, 0, 0, 1452, 1453,
		1, 0, 0, 0, 1453, 1456, 1, 0, 0, 0, 1454, 1452, 1, 0, 0, 0, 1455, 1457,
		5, 46, 0, 0, 1456, 1455, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1459,
		1, 0, 0, 0, 1458, 1460, 5, 45, 0, 0, 1459, 1458, 1, 0, 0, 0, 1459, 1460,
		1, 0, 0, 0, 1460, 1462, 1, 0, 0, 0, 1461, 1448, 1, 0, 0, 0, 1461, 1462,
		1, 0, 0, 0, 1462, 1476, 1, 0, 0, 0, 1463, 1467, 3, 80, 40, 0, 1464, 1466,
		5, 44, 0, 0, 1465, 1464, 1, 0, 0, 0, 1466, 1469, 1, 0, 0, 0, 1467, 1465,
		1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1471, 1, 0, 0, 0, 1469, 1467,
		1, 0, 0, 0, 1470, 1472, 5, 46, 0, 0, 1471, 1470, 1, 0, 0, 0, 1471, 1472,
		1, 0, 0, 0, 1472, 1474, 1, 0, 0, 0, 1473, 1475, 5, 45, 0, 0, 1474, 1473,
		1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1477, 1, 0, 0, 0, 1476, 1463,
		1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1482,
		3, 78, 39, 0, 1479, 1481, 5, 44, 0, 0, 1480, 1479, 1, 0, 0, 0, 1481, 1484,
		1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1482, 1483, 1, 0, 0, 0, 1483, 1486,
		1, 0, 0, 0, 1484, 1482, 1, 0, 0, 0, 1485, 1487, 5, 46, 0, 0, 1486, 1485,
		1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1489, 1, 0, 0, 0, 1488, 1490,
		5, 45, 0, 0, 1489, 1488, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1491,
		1, 0, 0, 0, 1491, 1495, 3, 84, 42, 0, 1492, 1494, 5, 44, 0, 0, 1493, 1492,
		1, 0, 0, 0, 1494, 1497, 1, 0, 0, 0, 1495, 1493, 1, 0, 0, 0, 1495, 1496,
		1, 0, 0, 0, 1496, 1499, 1, 0, 0, 0, 1497, 1495, 1, 0, 0, 0, 1498, 1500,
		5, 46, 0, 0, 1499, 1498, 1, 0, 0, 0, 1499, 1500, 1, 0, 0, 0, 1500, 1502,
		1, 0, 0, 0, 1501, 1503, 5, 45, 0, 0, 1502, 1501, 1, 0, 0, 0, 1502, 1503,
		1, 0, 0, 0, 1503, 1517, 1, 0, 0, 0, 1504, 1508, 3, 86, 43, 0, 1505, 1507,
		5, 44, 0, 0, 1506, 1505, 1, 0, 0, 0, 1507, 1510, 1, 0, 0, 0, 1508, 1506,
		1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 1512, 1, 0, 0, 0, 1510, 1508,
		1, 0, 0, 0, 1511, 1513, 5, 46, 0, 0, 1512, 1511, 1, 0, 0, 0, 1512, 1513,
		1, 0, 0, 0, 1513, 1515, 1, 0, 0, 0, 1514, 1516, 5, 45, 0, 0, 1515, 1514,
		1, 0, 0, 0, 1515, 1516, 1, 0, 0, 0, 1516, 1518, 1, 0, 0, 0, 1517, 1504,
		1, 0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 1520, 1, 0, 0, 0, 1519, 1521,
		3, 92, 46, 0, 1520, 1519, 1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521, 1525,
		1, 0, 0, 0, 1522, 1524, 5, 44, 0, 0, 1523, 1522, 1, 0, 0, 0, 1524, 1527,
		1, 0, 0, 0, 1525, 1523, 1, 0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 1529,
		1, 0, 0, 0, 1527, 1525, 1, 0, 0, 0, 1528, 1530, 5, 46, 0, 0, 1529, 1528,
		1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531, 1533,
		5, 45, 0, 0, 1532, 1531, 1, 0, 0, 0, 1532, 1533, 1, 0, 0, 0, 1533, 1537,
		1, 0, 0, 0, 1534, 1536, 5, 44, 0, 0, 1535, 1534, 1, 0, 0, 0, 1536, 1539,
		1, 0, 0, 0, 1537, 1535, 1, 0, 0, 0, 1537, 1538, 1, 0, 0, 0, 1538, 1541,
		1, 0, 0, 0, 1539, 1537, 1, 0, 0, 0, 1540, 1542, 5, 46, 0, 0, 1541, 1540,
		1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 1545,
		3, 104, 52, 0, 1544, 1546, 5, 46, 0, 0, 1545, 1544, 1, 0, 0, 0, 1545, 1546,
		1, 0, 0, 0, 1546, 77, 1, 0, 0, 0, 1547, 1548, 5, 43, 0, 0, 1548, 1549,
		3, 100, 50, 0, 1549, 79, 1, 0, 0, 0, 1550, 1551, 5, 28, 0, 0, 1551, 81,
		1, 0, 0, 0, 1552, 1553, 5, 32, 0, 0, 1553, 1554, 3, 110, 55, 0, 1554, 83,
		1, 0, 0, 0, 1555, 1558, 5, 38, 0, 0, 1556, 1559, 3, 100, 50, 0, 1557, 1559,
		3, 96, 48, 0, 1558, 1556, 1, 0, 0, 0, 1558, 1557, 1, 0, 0, 0, 1559, 85,
		1, 0, 0, 0, 1560, 1563, 5, 39, 0, 0, 1561, 1564, 3, 100, 50, 0, 1562, 1564,
		3, 96, 48, 0, 1563, 1561, 1, 0, 0, 0, 1563, 1562, 1, 0, 0, 0, 1564, 87,
		1, 0, 0, 0, 1565, 1566, 5, 35, 0, 0, 1566, 1567, 7, 1, 0, 0, 1567, 89,
		1, 0, 0, 0, 1568, 1644, 5, 36, 0, 0, 1569, 1645, 5, 9, 0, 0, 1570, 1574,
		3, 102, 51, 0, 1571, 1573, 5, 44, 0, 0, 1572, 1571, 1, 0, 0, 0, 1573, 1576,
		1, 0, 0, 0, 1574, 1572, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1578,
		1, 0, 0, 0, 1576, 1574, 1, 0, 0, 0, 1577, 1579, 5, 46, 0, 0, 1578, 1577,
		1, 0, 0, 0, 1578, 1579, 1, 0, 0, 0, 1579, 1581, 1, 0, 0, 0, 1580, 1582,
		5, 45, 0, 0, 1581, 1580, 1, 0, 0, 0, 1581, 1582, 1, 0, 0, 0, 1582, 1586,
		1, 0, 0, 0, 1583, 1585, 5, 44, 0, 0, 1584, 1583, 1, 0, 0, 0, 1585, 1588,
		1, 0, 0, 0, 1586, 1584, 1, 0, 0, 0, 1586, 1587, 1, 0, 0, 0, 1587, 1590,
		1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1589, 1591, 5, 46, 0, 0, 1590, 1589,
		1, 0, 0, 0, 1590, 1591, 1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592, 1596,
		5, 9, 0, 0, 1593, 1595, 5, 44, 0, 0, 1594, 1593, 1, 0, 0, 0, 1595, 1598,
		1, 0, 0, 0, 1596, 1594, 1, 0, 0, 0, 1596, 1597, 1, 0, 0, 0, 1597, 1600,
		1, 0, 0, 0, 1598, 1596, 1, 0, 0, 0, 1599, 1601, 5, 46, 0, 0, 1600, 1599,
		1, 0, 0, 0, 1600, 1601, 1, 0, 0, 0, 1601, 1603, 1, 0, 0, 0, 1602, 1604,
		5, 45, 0, 0, 1603, 1602, 1, 0, 0, 0, 1603, 1604, 1, 0, 0, 0, 1604, 1613,
		1, 0, 0, 0, 1605, 1607, 5, 44, 0, 0, 1606, 1605, 1, 0, 0, 0, 1607, 1608,
		1, 0, 0, 0, 1608, 1606, 1, 0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1610,
		1, 0, 0, 0, 1610, 1612, 5, 9, 0, 0, 1611, 1606, 1, 0, 0, 0, 1612, 1615,
		1, 0, 0, 0, 1613, 1611, 1, 0, 0, 0, 1613, 1614, 1, 0, 0, 0, 1614, 1619,
		1, 0, 0, 0, 1615, 1613, 1, 0, 0, 0, 1616, 1618, 5, 44, 0, 0, 1617, 1616,
		1, 0, 0, 0, 1618, 1621, 1, 0, 0, 0, 1619, 1617, 1, 0, 0, 0, 1619, 1620,
		1, 0, 0, 0, 1620, 1623, 1, 0, 0, 0, 1621, 1619, 1, 0, 0, 0, 1622, 1624,
		5, 46, 0, 0, 1623, 1622, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1626,
		1, 0, 0, 0, 1625, 1627, 5, 45, 0, 0, 1626, 1625, 1, 0, 0, 0, 1626, 1627,
		1, 0, 0, 0, 1627, 1631, 1, 0, 0, 0, 1628, 1630, 5, 44, 0, 0, 1629, 1628,
		1, 0, 0, 0, 1630, 1633, 1, 0, 0, 0, 1631, 1629, 1, 0, 0, 0, 1631, 1632,
		1, 0, 0, 0, 1632, 1634, 1, 0, 0, 0, 1633, 1631, 1, 0, 0, 0, 1634, 1638,
		3, 104, 52, 0, 1635, 1637, 5, 44, 0, 0, 1636, 1635, 1, 0, 0, 0, 1637, 1640,
		1, 0, 0, 0, 1638, 1636, 1, 0, 0, 0, 1638, 1639, 1, 0, 0, 0, 1639, 1642,
		1, 0, 0, 0, 1640, 1638, 1, 0, 0, 0, 1641, 1643, 5, 46, 0, 0, 1642, 1641,
		1, 0, 0, 0, 1642, 1643, 1, 0, 0, 0, 1643, 1645, 1, 0, 0, 0, 1644, 1569,
		1, 0, 0, 0, 1644, 1570, 1, 0, 0, 0, 1645, 91, 1, 0, 0, 0, 1646, 1648, 3,
		94, 47, 0, 1647, 1646, 1, 0, 0, 0, 1648, 1649, 1, 0, 0, 0, 1649, 1647,
		1, 0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650, 93, 1, 0, 0, 0, 1651, 1653, 5,
		45, 0, 0, 1652, 1651, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1654, 1,
		0, 0, 0, 1654, 1730, 5, 8, 0, 0, 1655, 1731, 3, 120, 60, 0, 1656, 1660,
		3, 102, 51, 0, 1657, 1659, 5, 44, 0, 0, 1658, 1657, 1, 0, 0, 0, 1659, 1662,
		1, 0, 0, 0, 1660, 1658, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1664,
		1, 0, 0, 0, 1662, 1660, 1, 0, 0, 0, 1663, 1665, 5, 46, 0, 0, 1664, 1663,
		1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1667, 1, 0, 0, 0, 1666, 1668,
		5, 45, 0, 0, 1667, 1666, 1, 0, 0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 1672,
		1, 0, 0, 0, 1669, 1671, 5, 44, 0, 0, 1670, 1669, 1, 0, 0, 0, 1671, 1674,
		1, 0, 0, 0, 1672, 1670, 1, 0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1676,
		1, 0, 0, 0, 1674, 1672, 1, 0, 0, 0, 1675, 1677, 5, 46, 0, 0, 1676, 1675,
		1, 0, 0, 0, 1676, 1677, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 1682,
		3, 120, 60, 0, 1679, 1681, 5, 44, 0, 0, 1680, 1679, 1, 0, 0, 0, 1681, 1684,
		1, 0, 0, 0, 1682, 1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1686,
		1, 0, 0, 0, 1684, 1682, 1, 0, 0, 0, 1685, 1687, 5, 46, 0, 0, 1686, 1685,
		1, 0, 0, 0, 1686, 1687, 1, 0, 0, 0, 1687, 1689, 1, 0, 0, 0, 1688, 1690,
		5, 45, 0, 0, 1689, 1688, 1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1699,
		1, 0, 0, 0, 1691, 1693, 5, 44, 0, 0, 1692, 1691, 1, 0, 0, 0, 1693, 1694,
		1, 0, 0, 0, 1694, 1692, 1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 1696,
		1, 0, 0, 0, 1696, 1698, 3, 120, 60, 0, 1697, 1692, 1, 0, 0, 0, 1698, 1701,
		1, 0, 0, 0, 1699, 1697, 1, 0, 0, 0, 1699, 1700, 1, 0, 0, 0, 1700, 1705,
		1, 0, 0, 0, 1701, 1699, 1, 0, 0, 0, 1702, 1704, 5, 44, 0, 0, 1703, 1702,
		1, 0, 0, 0, 1704, 1707, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1706,
		1, 0, 0, 0, 1706, 1709, 1, 0, 0, 0, 1707, 1705, 1, 0, 0, 0, 1708, 1710,
		5, 46, 0, 0, 1709, 1708, 1, 0, 0, 0, 1709, 1710, 1, 0, 0, 0, 1710, 1712,
		1, 0, 0, 0, 1711, 1713, 5, 45, 0, 0, 1712, 1711, 1, 0, 0, 0, 1712, 1713,
		1, 0, 0, 0, 1713, 1717, 1, 0, 0, 0, 1714, 1716, 5, 44, 0, 0, 1715, 1714,
		1, 0, 0, 0, 1716, 1719, 1, 0, 0, 0, 1717, 1715, 1, 0, 0, 0, 1717, 1718,
		1, 0, 0, 0, 1718, 1720, 1, 0, 0, 0, 1719, 1717, 1, 0, 0, 0, 1720, 1724,
		3, 104, 52, 0, 1721, 1723, 5, 44, 0, 0, 1722, 1721, 1, 0, 0, 0, 1723, 1726,
		1, 0, 0, 0, 1724, 1722, 1, 0, 0, 0, 1724, 1725, 1, 0, 0, 0, 1725, 1728,
		1, 0, 0, 0, 1726, 1724, 1, 0, 0, 0, 1727, 1729, 5, 46, 0, 0, 1728, 1727,
		1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1731, 1, 0, 0, 0, 1730, 1655,
		1, 0, 0, 0, 1730, 1656, 1, 0, 0, 0, 1731, 95, 1, 0, 0, 0, 1732, 1736, 3,
		102, 51, 0, 1733, 1735, 5, 44, 0, 0, 1734, 1733, 1, 0, 0, 0, 1735, 1738,
		1, 0, 0, 0, 1736, 1734, 1, 0, 0, 0, 1736, 1737, 1, 0, 0, 0, 1737, 1740,
		1, 0, 0, 0, 1738, 1736, 1, 0, 0, 0, 1739, 1741, 5, 46, 0, 0, 1740, 1739,
		1, 0, 0, 0, 1740, 1741, 1, 0, 0, 0, 1741, 1743, 1, 0, 0, 0, 1742, 1744,
		5, 45, 0, 0, 1743, 1742, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 1748,
		1, 0, 0, 0, 1745, 1747, 5, 44, 0, 0, 1746, 1745, 1, 0, 0, 0, 1747, 1750,
		1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1751,
		1, 0, 0, 0, 1750, 1748, 1, 0, 0, 0, 1751, 1755, 3, 100, 50, 0, 1752, 1754,
		5, 44, 0, 0, 1753, 1752, 1, 0, 0, 0, 1754, 1757, 1, 0, 0, 0, 1755, 1753,
		1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756, 1759, 1, 0, 0, 0, 1757, 1755,
		1, 0, 0, 0, 1758, 1760, 5, 46, 0, 0, 1759, 1758, 1, 0, 0, 0, 1759, 1760,
		1, 0, 0, 0, 1760, 1762, 1, 0, 0, 0, 1761, 1763, 5, 45, 0, 0, 1762, 1761,
		1, 0, 0, 0, 1762, 1763, 1, 0, 0, 0, 1763, 1774, 1, 0, 0, 0, 1764, 1768,
		5, 4, 0, 0, 1765, 1767, 5, 44, 0, 0, 1766, 1765, 1, 0, 0, 0, 1767, 1770,
		1, 0, 0, 0, 1768, 1766, 1, 0, 0, 0, 1768, 1769, 1, 0, 0, 0, 1769, 1771,
		1, 0, 0, 0, 1770, 1768, 1, 0, 0, 0, 1771, 1773, 3, 100, 50, 0, 1772, 1764,
		1, 0, 0, 0, 1773, 1776, 1, 0, 0, 0, 1774, 1772, 1, 0, 0, 0, 1774, 1775,
		1, 0, 0, 0, 1775, 1780, 1, 0, 0, 0, 1776, 1774, 1, 0, 0, 0, 1777, 1779,
		5, 44, 0, 0, 1778, 1777, 1, 0, 0, 0, 1779, 1782, 1, 0, 0, 0, 1780, 1778,
		1, 0, 0, 0, 1780, 1781, 1, 0, 0, 0, 1781, 1784, 1, 0, 0, 0, 1782, 1780,
		1, 0, 0, 0, 1783, 1785, 5, 46, 0, 0, 1784, 1783, 1, 0, 0, 0, 1784, 1785,
		1, 0, 0, 0, 1785, 1787, 1, 0, 0, 0, 1786, 1788, 5, 45, 0, 0, 1787, 1786,
		1, 0, 0, 0, 1787, 1788, 1, 0, 0, 0, 1788, 1792, 1, 0, 0, 0, 1789, 1791,
		5, 44, 0, 0, 1790, 1789, 1, 0, 0, 0, 1791, 1794, 1, 0, 0, 0, 1792, 1790,
		1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793, 1796, 1, 0, 0, 0, 1794, 1792,
		1, 0, 0, 0, 1795, 1797, 5, 46, 0, 0, 1796, 1795, 1, 0, 0, 0, 1796, 1797,
		1, 0, 0, 0, 1797, 1798, 1, 0, 0, 0, 1798, 1802, 3, 104, 52, 0, 1799, 1801,
		5, 44, 0, 0, 1800, 1799, 1, 0, 0, 0, 1801, 1804, 1, 0, 0, 0, 1802, 1800,
		1, 0, 0, 0, 1802, 1803, 1, 0, 0, 0, 1803, 1806, 1, 0, 0, 0, 1804, 1802,
		1, 0, 0, 0, 1805, 1807, 5, 46, 0, 0, 1806, 1805, 1, 0, 0, 0, 1806, 1807,
		1, 0, 0, 0, 1807, 97, 1, 0, 0, 0, 1808, 1810, 3, 100, 50, 0, 1809, 1811,
		3, 116, 58, 0, 1810, 1809, 1, 0, 0, 0, 1810, 1811, 1, 0, 0, 0, 1811, 99,
		1, 0, 0, 0, 1812, 1815, 3, 118, 59, 0, 1813, 1815, 3, 110, 55, 0, 1814,
		1812, 1, 0, 0, 0, 1814, 1813, 1, 0, 0, 0, 1815, 101, 1, 0, 0, 0, 1816,
		1817, 5, 2, 0, 0, 1817, 103, 1, 0, 0, 0, 1818, 1819, 5, 3, 0, 0, 1819,
		105, 1, 0, 0, 0, 1820, 1823, 3, 108, 54, 0, 1821, 1823, 3, 110, 55, 0,
		1822, 1820, 1, 0, 0, 0, 1822, 1821, 1, 0, 0, 0, 1823, 107, 1, 0, 0, 0,
		1824, 1825, 3, 118, 59, 0, 1825, 1826, 3, 112, 56, 0, 1826, 109, 1, 0,
		0, 0, 1827, 1828, 5, 7, 0, 0, 1828, 111, 1, 0, 0, 0, 1829, 1830, 5, 6,
		0, 0, 1830, 113, 1, 0, 0, 0, 1831, 1832, 5, 12, 0, 0, 1832, 115, 1, 0,
		0, 0, 1833, 1834, 5, 1, 0, 0, 1834, 1836, 3, 118, 59, 0, 1835, 1833, 1,
		0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837, 1835, 1, 0, 0, 0, 1837, 1838, 1,
		0, 0, 0, 1838, 117, 1, 0, 0, 0, 1839, 1840, 5, 13, 0, 0, 1840, 119, 1,
		0, 0, 0, 1841, 1842, 7, 1, 0, 0, 1842, 121, 1, 0, 0, 0, 390, 123, 126,
		140, 142, 149, 156, 162, 166, 169, 174, 181, 185, 188, 194, 198, 201, 203,
		209, 213, 216, 218, 224, 228, 231, 233, 239, 243, 246, 248, 254, 258, 261,
		263, 269, 273, 276, 278, 284, 288, 291, 293, 296, 301, 305, 308, 313, 317,
		321, 326, 337, 344, 351, 357, 361, 364, 369, 376, 380, 383, 389, 393, 396,
		398, 404, 408, 411, 413, 419, 423, 426, 428, 434, 438, 441, 443, 449, 453,
		456, 458, 464, 468, 471, 473, 479, 483, 486, 488, 492, 497, 501, 504, 506,
		510, 515, 519, 522, 524, 530, 534, 537, 539, 545, 549, 552, 554, 557, 562,
		566, 569, 574, 578, 582, 612, 619, 625, 629, 632, 637, 644, 648, 651, 657,
		661, 664, 666, 672, 676, 679, 681, 687, 691, 694, 696, 702, 706, 709, 711,
		714, 719, 723, 726, 731, 735, 739, 746, 753, 759, 763, 766, 771, 778, 782,
		785, 791, 795, 798, 800, 806, 810, 813, 815, 821, 825, 828, 830, 836, 840,
		843, 845, 848, 853, 857, 860, 865, 869, 873, 878, 885, 892, 898, 902, 905,
		910, 917, 921, 924, 930, 934, 937, 939, 942, 947, 951, 954, 959, 963, 967,
		974, 981, 987, 991, 994, 999, 1006, 1010, 1013, 1019, 1023, 1026, 1028,
		1034, 1038, 1041, 1043, 1049, 1053, 1056, 1058, 1064, 1068, 1071, 1073,
		1079, 1083, 1086, 1088, 1094, 1098, 1101, 1103, 1109, 1113, 1116, 1118,
		1121, 1126, 1130, 1133, 1138, 1142, 1149, 1154, 1161, 1168, 1174, 1178,
		1181, 1186, 1193, 1197, 1200, 1206, 1210, 1213, 1215, 1221, 1225, 1228,
		1230, 1236, 1240, 1243, 1245, 1251, 1255, 1258, 1264, 1268, 1271, 1273,
		1276, 1281, 1285, 1288, 1293, 1297, 1301, 1307, 1311, 1314, 1319, 1323,
		1329, 1333, 1336, 1341, 1346, 1352, 1356, 1359, 1364, 1371, 1375, 1380,
		1392, 1399, 1405, 1409, 1412, 1417, 1424, 1428, 1431, 1437, 1441, 1444,
		1446, 1452, 1456, 1459, 1461, 1467, 1471, 1474, 1476, 1482, 1486, 1489,
		1495, 1499, 1502, 1508, 1512, 1515, 1517, 1520, 1525, 1529, 1532, 1537,
		1541, 1545, 1558, 1563, 1574, 1578, 1581, 1586, 1590, 1596, 1600, 1603,
		1608, 1613, 1619, 1623, 1626, 1631, 1638, 1642, 1644, 1649, 1652, 1660,
		1664, 1667, 1672, 1676, 1682, 1686, 1689, 1694, 1699, 1705, 1709, 1712,
		1717, 1724, 1728, 1730, 1736, 1740, 1743, 1748, 1755, 1759, 1762, 1768,
		1774, 1780, 1784, 1787, 1792, 1796, 1802, 1806, 1810, 1814, 1822, 1837,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// RFC4512ParserInit initializes any static state used to implement RFC4512Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewRFC4512Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func RFC4512ParserInit() {
	staticData := &RFC4512ParserStaticData
	staticData.once.Do(rfc4512ParserInit)
}

// NewRFC4512Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewRFC4512Parser(input antlr.TokenStream) *RFC4512Parser {
	RFC4512ParserInit()
	this := new(RFC4512Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &RFC4512ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "RFC4512.g4"

	return this
}

// RFC4512Parser tokens.
const (
	RFC4512ParserEOF              = antlr.TokenEOF
	RFC4512ParserT__0             = 1
	RFC4512ParserOpenParenthesis  = 2
	RFC4512ParserCloseParenthesis = 3
	RFC4512ParserODelim           = 4
	RFC4512ParserUsage            = 5
	RFC4512ParserMacroSuffix      = 6
	RFC4512ParserNumOID           = 7
	RFC4512ParserExtensionName    = 8
	RFC4512ParserQuotedDescriptor = 9
	RFC4512ParserQuotedString     = 10
	RFC4512ParserMinUpperBounds   = 11
	RFC4512ParserDigit            = 12
	RFC4512ParserDescr            = 13
	RFC4512ParserDSRL             = 14
	RFC4512ParserDCRL             = 15
	RFC4512ParserNFL              = 16
	RFC4512ParserATL              = 17
	RFC4512ParserOCL              = 18
	RFC4512ParserLSL              = 19
	RFC4512ParserMRL              = 20
	RFC4512ParserMRUL             = 21
	RFC4512ParserNOMODS           = 22
	RFC4512ParserSINGLEVAL        = 23
	RFC4512ParserSTRUCTURAL       = 24
	RFC4512ParserCOLLECTIVE       = 25
	RFC4512ParserAUXILIARY        = 26
	RFC4512ParserABSTRACT         = 27
	RFC4512ParserOBSOLETE         = 28
	RFC4512ParserORDERING         = 29
	RFC4512ParserEQUALITY         = 30
	RFC4512ParserAPPLIES          = 31
	RFC4512ParserSYNTAX           = 32
	RFC4512ParserSUBSTR           = 33
	RFC4512ParserUSAGE            = 34
	RFC4512ParserDESC             = 35
	RFC4512ParserNAME             = 36
	RFC4512ParserFORM             = 37
	RFC4512ParserMUST             = 38
	RFC4512ParserMAY              = 39
	RFC4512ParserNOT              = 40
	RFC4512ParserSUP              = 41
	RFC4512ParserAUX              = 42
	RFC4512ParserOC               = 43
	RFC4512ParserSP               = 44
	RFC4512ParserNEWLINE          = 45
	RFC4512ParserLineComment      = 46
)

// RFC4512Parser rules.
const (
	RFC4512ParserRULE_parse                        = 0
	RFC4512ParserRULE_definitions                  = 1
	RFC4512ParserRULE_objectClassDescriptions      = 2
	RFC4512ParserRULE_objectClassDescription       = 3
	RFC4512ParserRULE_oCKind                       = 4
	RFC4512ParserRULE_abstractKind                 = 5
	RFC4512ParserRULE_structuralKind               = 6
	RFC4512ParserRULE_auxiliaryKind                = 7
	RFC4512ParserRULE_oCSuperClasses               = 8
	RFC4512ParserRULE_attributeTypeDescriptions    = 9
	RFC4512ParserRULE_attributeTypeDescription     = 10
	RFC4512ParserRULE_minimumUpperBounds           = 11
	RFC4512ParserRULE_aTEquality                   = 12
	RFC4512ParserRULE_aTOrdering                   = 13
	RFC4512ParserRULE_aTSubstring                  = 14
	RFC4512ParserRULE_aTSuperType                  = 15
	RFC4512ParserRULE_aTUsage                      = 16
	RFC4512ParserRULE_aTSingleValue                = 17
	RFC4512ParserRULE_aTCollective                 = 18
	RFC4512ParserRULE_aTNoUserModification         = 19
	RFC4512ParserRULE_matchingRuleDescriptions     = 20
	RFC4512ParserRULE_matchingRuleDescription      = 21
	RFC4512ParserRULE_matchingRuleUseDescriptions  = 22
	RFC4512ParserRULE_matchingRuleUseDescription   = 23
	RFC4512ParserRULE_mRUApplies                   = 24
	RFC4512ParserRULE_lDAPSyntaxDescriptions       = 25
	RFC4512ParserRULE_lDAPSyntaxDescription        = 26
	RFC4512ParserRULE_dITContentRuleDescriptions   = 27
	RFC4512ParserRULE_dITContentRuleDescription    = 28
	RFC4512ParserRULE_dCRNot                       = 29
	RFC4512ParserRULE_dCRAux                       = 30
	RFC4512ParserRULE_dITStructureRuleDescriptions = 31
	RFC4512ParserRULE_dITStructureRuleDescription  = 32
	RFC4512ParserRULE_structureRules               = 33
	RFC4512ParserRULE_dSRSuperRules                = 34
	RFC4512ParserRULE_structureRule                = 35
	RFC4512ParserRULE_dSRForm                      = 36
	RFC4512ParserRULE_nameFormDescriptions         = 37
	RFC4512ParserRULE_nameFormDescription          = 38
	RFC4512ParserRULE_nFStructuralOC               = 39
	RFC4512ParserRULE_definitionObsolete           = 40
	RFC4512ParserRULE_definitionSyntax             = 41
	RFC4512ParserRULE_definitionMust               = 42
	RFC4512ParserRULE_definitionMay                = 43
	RFC4512ParserRULE_definitionDescription        = 44
	RFC4512ParserRULE_definitionName               = 45
	RFC4512ParserRULE_definitionExtensions         = 46
	RFC4512ParserRULE_definitionExtension          = 47
	RFC4512ParserRULE_oIDs                         = 48
	RFC4512ParserRULE_attributeDescription         = 49
	RFC4512ParserRULE_oID                          = 50
	RFC4512ParserRULE_openParen                    = 51
	RFC4512ParserRULE_closeParen                   = 52
	RFC4512ParserRULE_numericOIDOrMacro            = 53
	RFC4512ParserRULE_macro                        = 54
	RFC4512ParserRULE_numericOID                   = 55
	RFC4512ParserRULE_macroSuffix                  = 56
	RFC4512ParserRULE_number                       = 57
	RFC4512ParserRULE_attrOptions                  = 58
	RFC4512ParserRULE_descriptor                   = 59
	RFC4512ParserRULE_extensionValue               = 60
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Definitions() IDefinitionsContext
	EOF() antlr.TerminalNode
	NEWLINE() antlr.TerminalNode
	LineComment() antlr.TerminalNode

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_parse
	return p
}

func InitEmptyParseContext(p *ParseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_parse
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) Definitions() IDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionsContext)
}

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, 0)
}

func (s *ParseContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, 0)
}

func (s *ParseContext) LineComment() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, 0)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitParse(s)
	}
}

func (p *RFC4512Parser) Parse() (localctx IParseContext) {
	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, RFC4512ParserRULE_parse)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(122)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(126)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(125)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(128)
		p.Definitions()
	}
	{
		p.SetState(129)
		p.Match(RFC4512ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionsContext is an interface to support dynamic dispatch.
type IDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllLDAPSyntaxDescriptions() []ILDAPSyntaxDescriptionsContext
	LDAPSyntaxDescriptions(i int) ILDAPSyntaxDescriptionsContext
	AllMatchingRuleDescriptions() []IMatchingRuleDescriptionsContext
	MatchingRuleDescriptions(i int) IMatchingRuleDescriptionsContext
	AllAttributeTypeDescriptions() []IAttributeTypeDescriptionsContext
	AttributeTypeDescriptions(i int) IAttributeTypeDescriptionsContext
	AllMatchingRuleUseDescriptions() []IMatchingRuleUseDescriptionsContext
	MatchingRuleUseDescriptions(i int) IMatchingRuleUseDescriptionsContext
	AllObjectClassDescriptions() []IObjectClassDescriptionsContext
	ObjectClassDescriptions(i int) IObjectClassDescriptionsContext
	AllDITContentRuleDescriptions() []IDITContentRuleDescriptionsContext
	DITContentRuleDescriptions(i int) IDITContentRuleDescriptionsContext
	AllNameFormDescriptions() []INameFormDescriptionsContext
	NameFormDescriptions(i int) INameFormDescriptionsContext
	AllDITStructureRuleDescriptions() []IDITStructureRuleDescriptionsContext
	DITStructureRuleDescriptions(i int) IDITStructureRuleDescriptionsContext

	// IsDefinitionsContext differentiates from other interfaces.
	IsDefinitionsContext()
}

type DefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionsContext() *DefinitionsContext {
	var p = new(DefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitions
	return p
}

func InitEmptyDefinitionsContext(p *DefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitions
}

func (*DefinitionsContext) IsDefinitionsContext() {}

func NewDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionsContext {
	var p = new(DefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitions

	return p
}

func (s *DefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionsContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *DefinitionsContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *DefinitionsContext) AllLDAPSyntaxDescriptions() []ILDAPSyntaxDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILDAPSyntaxDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]ILDAPSyntaxDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILDAPSyntaxDescriptionsContext); ok {
			tst[i] = t.(ILDAPSyntaxDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) LDAPSyntaxDescriptions(i int) ILDAPSyntaxDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPSyntaxDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPSyntaxDescriptionsContext)
}

func (s *DefinitionsContext) AllMatchingRuleDescriptions() []IMatchingRuleDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchingRuleDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]IMatchingRuleDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchingRuleDescriptionsContext); ok {
			tst[i] = t.(IMatchingRuleDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) MatchingRuleDescriptions(i int) IMatchingRuleDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchingRuleDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchingRuleDescriptionsContext)
}

func (s *DefinitionsContext) AllAttributeTypeDescriptions() []IAttributeTypeDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeDescriptionsContext); ok {
			tst[i] = t.(IAttributeTypeDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) AttributeTypeDescriptions(i int) IAttributeTypeDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeDescriptionsContext)
}

func (s *DefinitionsContext) AllMatchingRuleUseDescriptions() []IMatchingRuleUseDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchingRuleUseDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]IMatchingRuleUseDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchingRuleUseDescriptionsContext); ok {
			tst[i] = t.(IMatchingRuleUseDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) MatchingRuleUseDescriptions(i int) IMatchingRuleUseDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchingRuleUseDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchingRuleUseDescriptionsContext)
}

func (s *DefinitionsContext) AllObjectClassDescriptions() []IObjectClassDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectClassDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]IObjectClassDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectClassDescriptionsContext); ok {
			tst[i] = t.(IObjectClassDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) ObjectClassDescriptions(i int) IObjectClassDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectClassDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectClassDescriptionsContext)
}

func (s *DefinitionsContext) AllDITContentRuleDescriptions() []IDITContentRuleDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDITContentRuleDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]IDITContentRuleDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDITContentRuleDescriptionsContext); ok {
			tst[i] = t.(IDITContentRuleDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) DITContentRuleDescriptions(i int) IDITContentRuleDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDITContentRuleDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDITContentRuleDescriptionsContext)
}

func (s *DefinitionsContext) AllNameFormDescriptions() []INameFormDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameFormDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]INameFormDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameFormDescriptionsContext); ok {
			tst[i] = t.(INameFormDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) NameFormDescriptions(i int) INameFormDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameFormDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameFormDescriptionsContext)
}

func (s *DefinitionsContext) AllDITStructureRuleDescriptions() []IDITStructureRuleDescriptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDITStructureRuleDescriptionsContext); ok {
			len++
		}
	}

	tst := make([]IDITStructureRuleDescriptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDITStructureRuleDescriptionsContext); ok {
			tst[i] = t.(IDITStructureRuleDescriptionsContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionsContext) DITStructureRuleDescriptions(i int) IDITStructureRuleDescriptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDITStructureRuleDescriptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDITStructureRuleDescriptionsContext)
}

func (s *DefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitions(s)
	}
}

func (s *DefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitions(s)
	}
}

func (p *RFC4512Parser) Definitions() (localctx IDefinitionsContext) {
	localctx = NewDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, RFC4512ParserRULE_definitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70368748355584) != 0) {
		p.SetState(140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case RFC4512ParserLineComment:
			{
				p.SetState(131)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case RFC4512ParserLSL:
			{
				p.SetState(132)
				p.LDAPSyntaxDescriptions()
			}

		case RFC4512ParserMRL:
			{
				p.SetState(133)
				p.MatchingRuleDescriptions()
			}

		case RFC4512ParserATL:
			{
				p.SetState(134)
				p.AttributeTypeDescriptions()
			}

		case RFC4512ParserMRUL:
			{
				p.SetState(135)
				p.MatchingRuleUseDescriptions()
			}

		case RFC4512ParserOCL:
			{
				p.SetState(136)
				p.ObjectClassDescriptions()
			}

		case RFC4512ParserDCRL:
			{
				p.SetState(137)
				p.DITContentRuleDescriptions()
			}

		case RFC4512ParserNFL:
			{
				p.SetState(138)
				p.NameFormDescriptions()
			}

		case RFC4512ParserDSRL:
			{
				p.SetState(139)
				p.DITStructureRuleDescriptions()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectClassDescriptionsContext is an interface to support dynamic dispatch.
type IObjectClassDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOCL() []antlr.TerminalNode
	OCL(i int) antlr.TerminalNode
	AllObjectClassDescription() []IObjectClassDescriptionContext
	ObjectClassDescription(i int) IObjectClassDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsObjectClassDescriptionsContext differentiates from other interfaces.
	IsObjectClassDescriptionsContext()
}

type ObjectClassDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassDescriptionsContext() *ObjectClassDescriptionsContext {
	var p = new(ObjectClassDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_objectClassDescriptions
	return p
}

func InitEmptyObjectClassDescriptionsContext(p *ObjectClassDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_objectClassDescriptions
}

func (*ObjectClassDescriptionsContext) IsObjectClassDescriptionsContext() {}

func NewObjectClassDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassDescriptionsContext {
	var p = new(ObjectClassDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_objectClassDescriptions

	return p
}

func (s *ObjectClassDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassDescriptionsContext) AllOCL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserOCL)
}

func (s *ObjectClassDescriptionsContext) OCL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserOCL, i)
}

func (s *ObjectClassDescriptionsContext) AllObjectClassDescription() []IObjectClassDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectClassDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IObjectClassDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectClassDescriptionContext); ok {
			tst[i] = t.(IObjectClassDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *ObjectClassDescriptionsContext) ObjectClassDescription(i int) IObjectClassDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectClassDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectClassDescriptionContext)
}

func (s *ObjectClassDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *ObjectClassDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *ObjectClassDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *ObjectClassDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *ObjectClassDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *ObjectClassDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *ObjectClassDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterObjectClassDescriptions(s)
	}
}

func (s *ObjectClassDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitObjectClassDescriptions(s)
	}
}

func (p *RFC4512Parser) ObjectClassDescriptions() (localctx IObjectClassDescriptionsContext) {
	localctx = NewObjectClassDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, RFC4512ParserRULE_objectClassDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(144)
				p.Match(RFC4512ParserOCL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(145)
				p.ObjectClassDescription()
			}
			p.SetState(149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(146)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(151)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(152)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(156)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectClassDescriptionContext is an interface to support dynamic dispatch.
type IObjectClassDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	OCSuperClasses() IOCSuperClassesContext
	OCKind() IOCKindContext
	DefinitionMust() IDefinitionMustContext
	DefinitionMay() IDefinitionMayContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsObjectClassDescriptionContext differentiates from other interfaces.
	IsObjectClassDescriptionContext()
}

type ObjectClassDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassDescriptionContext() *ObjectClassDescriptionContext {
	var p = new(ObjectClassDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_objectClassDescription
	return p
}

func InitEmptyObjectClassDescriptionContext(p *ObjectClassDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_objectClassDescription
}

func (*ObjectClassDescriptionContext) IsObjectClassDescriptionContext() {}

func NewObjectClassDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassDescriptionContext {
	var p = new(ObjectClassDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_objectClassDescription

	return p
}

func (s *ObjectClassDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *ObjectClassDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *ObjectClassDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *ObjectClassDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *ObjectClassDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *ObjectClassDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *ObjectClassDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *ObjectClassDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *ObjectClassDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *ObjectClassDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *ObjectClassDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *ObjectClassDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *ObjectClassDescriptionContext) OCSuperClasses() IOCSuperClassesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOCSuperClassesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOCSuperClassesContext)
}

func (s *ObjectClassDescriptionContext) OCKind() IOCKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOCKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOCKindContext)
}

func (s *ObjectClassDescriptionContext) DefinitionMust() IDefinitionMustContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionMustContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionMustContext)
}

func (s *ObjectClassDescriptionContext) DefinitionMay() IDefinitionMayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionMayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionMayContext)
}

func (s *ObjectClassDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *ObjectClassDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterObjectClassDescription(s)
	}
}

func (s *ObjectClassDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitObjectClassDescription(s)
	}
}

func (p *RFC4512Parser) ObjectClassDescription() (localctx IObjectClassDescriptionContext) {
	localctx = NewObjectClassDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, RFC4512ParserRULE_objectClassDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(158)
		p.OpenParen()
	}
	p.SetState(162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(159)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(165)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(168)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(171)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(177)
		p.NumericOIDOrMacro()
	}
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(178)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(185)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(184)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(188)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(187)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(190)
			p.DefinitionName()
		}
		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(191)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(196)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(197)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(201)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(200)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(205)
			p.DefinitionDescription()
		}
		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(206)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(211)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(212)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(216)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(215)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(220)
			p.DefinitionObsolete()
		}
		p.SetState(224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(221)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(226)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(227)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(231)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(230)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSUP {
		{
			p.SetState(235)
			p.OCSuperClasses()
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(236)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(241)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(242)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(245)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&218103808) != 0 {
		{
			p.SetState(250)
			p.OCKind()
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(251)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(256)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(257)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(261)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(260)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserMUST {
		{
			p.SetState(265)
			p.DefinitionMust()
		}
		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(266)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(271)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(272)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(276)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(275)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserMAY {
		{
			p.SetState(280)
			p.DefinitionMay()
		}
		p.SetState(284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(281)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(286)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(287)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(290)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(295)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(298)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(305)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(304)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(307)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(310)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(316)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(319)
		p.CloseParen()
	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(320)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOCKindContext is an interface to support dynamic dispatch.
type IOCKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StructuralKind() IStructuralKindContext
	AuxiliaryKind() IAuxiliaryKindContext
	AbstractKind() IAbstractKindContext

	// IsOCKindContext differentiates from other interfaces.
	IsOCKindContext()
}

type OCKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOCKindContext() *OCKindContext {
	var p = new(OCKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oCKind
	return p
}

func InitEmptyOCKindContext(p *OCKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oCKind
}

func (*OCKindContext) IsOCKindContext() {}

func NewOCKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OCKindContext {
	var p = new(OCKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_oCKind

	return p
}

func (s *OCKindContext) GetParser() antlr.Parser { return s.parser }

func (s *OCKindContext) StructuralKind() IStructuralKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuralKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuralKindContext)
}

func (s *OCKindContext) AuxiliaryKind() IAuxiliaryKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuxiliaryKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuxiliaryKindContext)
}

func (s *OCKindContext) AbstractKind() IAbstractKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractKindContext)
}

func (s *OCKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OCKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OCKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterOCKind(s)
	}
}

func (s *OCKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitOCKind(s)
	}
}

func (p *RFC4512Parser) OCKind() (localctx IOCKindContext) {
	localctx = NewOCKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, RFC4512ParserRULE_oCKind)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserSTRUCTURAL:
		{
			p.SetState(323)
			p.StructuralKind()
		}

	case RFC4512ParserAUXILIARY:
		{
			p.SetState(324)
			p.AuxiliaryKind()
		}

	case RFC4512ParserABSTRACT:
		{
			p.SetState(325)
			p.AbstractKind()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbstractKindContext is an interface to support dynamic dispatch.
type IAbstractKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSTRACT() antlr.TerminalNode

	// IsAbstractKindContext differentiates from other interfaces.
	IsAbstractKindContext()
}

type AbstractKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractKindContext() *AbstractKindContext {
	var p = new(AbstractKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_abstractKind
	return p
}

func InitEmptyAbstractKindContext(p *AbstractKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_abstractKind
}

func (*AbstractKindContext) IsAbstractKindContext() {}

func NewAbstractKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractKindContext {
	var p = new(AbstractKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_abstractKind

	return p
}

func (s *AbstractKindContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractKindContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserABSTRACT, 0)
}

func (s *AbstractKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterAbstractKind(s)
	}
}

func (s *AbstractKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitAbstractKind(s)
	}
}

func (p *RFC4512Parser) AbstractKind() (localctx IAbstractKindContext) {
	localctx = NewAbstractKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, RFC4512ParserRULE_abstractKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(RFC4512ParserABSTRACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuralKindContext is an interface to support dynamic dispatch.
type IStructuralKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCTURAL() antlr.TerminalNode

	// IsStructuralKindContext differentiates from other interfaces.
	IsStructuralKindContext()
}

type StructuralKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuralKindContext() *StructuralKindContext {
	var p = new(StructuralKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_structuralKind
	return p
}

func InitEmptyStructuralKindContext(p *StructuralKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_structuralKind
}

func (*StructuralKindContext) IsStructuralKindContext() {}

func NewStructuralKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuralKindContext {
	var p = new(StructuralKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_structuralKind

	return p
}

func (s *StructuralKindContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuralKindContext) STRUCTURAL() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSTRUCTURAL, 0)
}

func (s *StructuralKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuralKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuralKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterStructuralKind(s)
	}
}

func (s *StructuralKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitStructuralKind(s)
	}
}

func (p *RFC4512Parser) StructuralKind() (localctx IStructuralKindContext) {
	localctx = NewStructuralKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, RFC4512ParserRULE_structuralKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.Match(RFC4512ParserSTRUCTURAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuxiliaryKindContext is an interface to support dynamic dispatch.
type IAuxiliaryKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUXILIARY() antlr.TerminalNode

	// IsAuxiliaryKindContext differentiates from other interfaces.
	IsAuxiliaryKindContext()
}

type AuxiliaryKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuxiliaryKindContext() *AuxiliaryKindContext {
	var p = new(AuxiliaryKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_auxiliaryKind
	return p
}

func InitEmptyAuxiliaryKindContext(p *AuxiliaryKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_auxiliaryKind
}

func (*AuxiliaryKindContext) IsAuxiliaryKindContext() {}

func NewAuxiliaryKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuxiliaryKindContext {
	var p = new(AuxiliaryKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_auxiliaryKind

	return p
}

func (s *AuxiliaryKindContext) GetParser() antlr.Parser { return s.parser }

func (s *AuxiliaryKindContext) AUXILIARY() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserAUXILIARY, 0)
}

func (s *AuxiliaryKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuxiliaryKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuxiliaryKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterAuxiliaryKind(s)
	}
}

func (s *AuxiliaryKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitAuxiliaryKind(s)
	}
}

func (p *RFC4512Parser) AuxiliaryKind() (localctx IAuxiliaryKindContext) {
	localctx = NewAuxiliaryKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, RFC4512ParserRULE_auxiliaryKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(332)
		p.Match(RFC4512ParserAUXILIARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOCSuperClassesContext is an interface to support dynamic dispatch.
type IOCSuperClassesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUP() antlr.TerminalNode
	OID() IOIDContext
	OIDs() IOIDsContext

	// IsOCSuperClassesContext differentiates from other interfaces.
	IsOCSuperClassesContext()
}

type OCSuperClassesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOCSuperClassesContext() *OCSuperClassesContext {
	var p = new(OCSuperClassesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oCSuperClasses
	return p
}

func InitEmptyOCSuperClassesContext(p *OCSuperClassesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oCSuperClasses
}

func (*OCSuperClassesContext) IsOCSuperClassesContext() {}

func NewOCSuperClassesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OCSuperClassesContext {
	var p = new(OCSuperClassesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_oCSuperClasses

	return p
}

func (s *OCSuperClassesContext) GetParser() antlr.Parser { return s.parser }

func (s *OCSuperClassesContext) SUP() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSUP, 0)
}

func (s *OCSuperClassesContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *OCSuperClassesContext) OIDs() IOIDsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDsContext)
}

func (s *OCSuperClassesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OCSuperClassesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OCSuperClassesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterOCSuperClasses(s)
	}
}

func (s *OCSuperClassesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitOCSuperClasses(s)
	}
}

func (p *RFC4512Parser) OCSuperClasses() (localctx IOCSuperClassesContext) {
	localctx = NewOCSuperClassesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, RFC4512ParserRULE_oCSuperClasses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Match(RFC4512ParserSUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserNumOID, RFC4512ParserDescr:
		{
			p.SetState(335)
			p.OID()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(336)
			p.OIDs()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTypeDescriptionsContext is an interface to support dynamic dispatch.
type IAttributeTypeDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllATL() []antlr.TerminalNode
	ATL(i int) antlr.TerminalNode
	AllAttributeTypeDescription() []IAttributeTypeDescriptionContext
	AttributeTypeDescription(i int) IAttributeTypeDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsAttributeTypeDescriptionsContext differentiates from other interfaces.
	IsAttributeTypeDescriptionsContext()
}

type AttributeTypeDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTypeDescriptionsContext() *AttributeTypeDescriptionsContext {
	var p = new(AttributeTypeDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attributeTypeDescriptions
	return p
}

func InitEmptyAttributeTypeDescriptionsContext(p *AttributeTypeDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attributeTypeDescriptions
}

func (*AttributeTypeDescriptionsContext) IsAttributeTypeDescriptionsContext() {}

func NewAttributeTypeDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTypeDescriptionsContext {
	var p = new(AttributeTypeDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_attributeTypeDescriptions

	return p
}

func (s *AttributeTypeDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTypeDescriptionsContext) AllATL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserATL)
}

func (s *AttributeTypeDescriptionsContext) ATL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserATL, i)
}

func (s *AttributeTypeDescriptionsContext) AllAttributeTypeDescription() []IAttributeTypeDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeDescriptionContext); ok {
			tst[i] = t.(IAttributeTypeDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *AttributeTypeDescriptionsContext) AttributeTypeDescription(i int) IAttributeTypeDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeDescriptionContext)
}

func (s *AttributeTypeDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *AttributeTypeDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *AttributeTypeDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *AttributeTypeDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *AttributeTypeDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *AttributeTypeDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *AttributeTypeDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTypeDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeTypeDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterAttributeTypeDescriptions(s)
	}
}

func (s *AttributeTypeDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitAttributeTypeDescriptions(s)
	}
}

func (p *RFC4512Parser) AttributeTypeDescriptions() (localctx IAttributeTypeDescriptionsContext) {
	localctx = NewAttributeTypeDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, RFC4512ParserRULE_attributeTypeDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(339)
				p.Match(RFC4512ParserATL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(340)
				p.AttributeTypeDescription()
			}
			p.SetState(344)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(341)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(346)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(347)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTypeDescriptionContext is an interface to support dynamic dispatch.
type IAttributeTypeDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	ATSuperType() IATSuperTypeContext
	ATEquality() IATEqualityContext
	ATOrdering() IATOrderingContext
	ATSubstring() IATSubstringContext
	DefinitionSyntax() IDefinitionSyntaxContext
	ATNoUserModification() IATNoUserModificationContext
	ATUsage() IATUsageContext
	DefinitionExtensions() IDefinitionExtensionsContext
	ATSingleValue() IATSingleValueContext
	ATCollective() IATCollectiveContext
	MinimumUpperBounds() IMinimumUpperBoundsContext

	// IsAttributeTypeDescriptionContext differentiates from other interfaces.
	IsAttributeTypeDescriptionContext()
}

type AttributeTypeDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTypeDescriptionContext() *AttributeTypeDescriptionContext {
	var p = new(AttributeTypeDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attributeTypeDescription
	return p
}

func InitEmptyAttributeTypeDescriptionContext(p *AttributeTypeDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attributeTypeDescription
}

func (*AttributeTypeDescriptionContext) IsAttributeTypeDescriptionContext() {}

func NewAttributeTypeDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTypeDescriptionContext {
	var p = new(AttributeTypeDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_attributeTypeDescription

	return p
}

func (s *AttributeTypeDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTypeDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *AttributeTypeDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *AttributeTypeDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *AttributeTypeDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *AttributeTypeDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *AttributeTypeDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *AttributeTypeDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *AttributeTypeDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *AttributeTypeDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *AttributeTypeDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *AttributeTypeDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *AttributeTypeDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *AttributeTypeDescriptionContext) ATSuperType() IATSuperTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATSuperTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATSuperTypeContext)
}

func (s *AttributeTypeDescriptionContext) ATEquality() IATEqualityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATEqualityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATEqualityContext)
}

func (s *AttributeTypeDescriptionContext) ATOrdering() IATOrderingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATOrderingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATOrderingContext)
}

func (s *AttributeTypeDescriptionContext) ATSubstring() IATSubstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATSubstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATSubstringContext)
}

func (s *AttributeTypeDescriptionContext) DefinitionSyntax() IDefinitionSyntaxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionSyntaxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionSyntaxContext)
}

func (s *AttributeTypeDescriptionContext) ATNoUserModification() IATNoUserModificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATNoUserModificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATNoUserModificationContext)
}

func (s *AttributeTypeDescriptionContext) ATUsage() IATUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATUsageContext)
}

func (s *AttributeTypeDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *AttributeTypeDescriptionContext) ATSingleValue() IATSingleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATSingleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATSingleValueContext)
}

func (s *AttributeTypeDescriptionContext) ATCollective() IATCollectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IATCollectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IATCollectiveContext)
}

func (s *AttributeTypeDescriptionContext) MinimumUpperBounds() IMinimumUpperBoundsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinimumUpperBoundsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinimumUpperBoundsContext)
}

func (s *AttributeTypeDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTypeDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeTypeDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterAttributeTypeDescription(s)
	}
}

func (s *AttributeTypeDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitAttributeTypeDescription(s)
	}
}

func (p *RFC4512Parser) AttributeTypeDescription() (localctx IAttributeTypeDescriptionContext) {
	localctx = NewAttributeTypeDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, RFC4512ParserRULE_attributeTypeDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(353)
		p.OpenParen()
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(354)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(360)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(363)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(366)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(372)
		p.NumericOIDOrMacro()
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(373)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(379)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(385)
			p.DefinitionName()
		}
		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(386)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(392)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(395)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(400)
			p.DefinitionDescription()
		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(401)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(406)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(407)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(410)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(415)
			p.DefinitionObsolete()
		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(416)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(421)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(422)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(425)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSUP {
		{
			p.SetState(430)
			p.ATSuperType()
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(431)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(436)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(438)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(437)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(440)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserEQUALITY {
		{
			p.SetState(445)
			p.ATEquality()
		}
		p.SetState(449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(446)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(451)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(452)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(455)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserORDERING {
		{
			p.SetState(460)
			p.ATOrdering()
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(461)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(468)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(467)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(470)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSUBSTR {
		{
			p.SetState(475)
			p.ATSubstring()
		}
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(476)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(481)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(483)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(482)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(485)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSYNTAX {
		{
			p.SetState(490)
			p.DefinitionSyntax()
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserMinUpperBounds {
			{
				p.SetState(491)
				p.MinimumUpperBounds()
			}

		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(494)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(499)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(500)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(504)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(503)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSINGLEVAL || _la == RFC4512ParserCOLLECTIVE {
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case RFC4512ParserSINGLEVAL:
			{
				p.SetState(508)
				p.ATSingleValue()
			}

		case RFC4512ParserCOLLECTIVE:
			{
				p.SetState(509)
				p.ATCollective()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(512)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(517)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(519)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(518)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(521)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNOMODS {
		{
			p.SetState(526)
			p.ATNoUserModification()
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(527)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(534)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(533)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(536)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserUSAGE {
		{
			p.SetState(541)
			p.ATUsage()
		}
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(542)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(549)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(548)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(551)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(556)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(559)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(565)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(568)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(571)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(577)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(580)
		p.CloseParen()
	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(581)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinimumUpperBoundsContext is an interface to support dynamic dispatch.
type IMinimumUpperBoundsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MinUpperBounds() antlr.TerminalNode

	// IsMinimumUpperBoundsContext differentiates from other interfaces.
	IsMinimumUpperBoundsContext()
}

type MinimumUpperBoundsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinimumUpperBoundsContext() *MinimumUpperBoundsContext {
	var p = new(MinimumUpperBoundsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_minimumUpperBounds
	return p
}

func InitEmptyMinimumUpperBoundsContext(p *MinimumUpperBoundsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_minimumUpperBounds
}

func (*MinimumUpperBoundsContext) IsMinimumUpperBoundsContext() {}

func NewMinimumUpperBoundsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinimumUpperBoundsContext {
	var p = new(MinimumUpperBoundsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_minimumUpperBounds

	return p
}

func (s *MinimumUpperBoundsContext) GetParser() antlr.Parser { return s.parser }

func (s *MinimumUpperBoundsContext) MinUpperBounds() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserMinUpperBounds, 0)
}

func (s *MinimumUpperBoundsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinimumUpperBoundsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinimumUpperBoundsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMinimumUpperBounds(s)
	}
}

func (s *MinimumUpperBoundsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMinimumUpperBounds(s)
	}
}

func (p *RFC4512Parser) MinimumUpperBounds() (localctx IMinimumUpperBoundsContext) {
	localctx = NewMinimumUpperBoundsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, RFC4512ParserRULE_minimumUpperBounds)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(RFC4512ParserMinUpperBounds)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATEqualityContext is an interface to support dynamic dispatch.
type IATEqualityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALITY() antlr.TerminalNode
	OID() IOIDContext

	// IsATEqualityContext differentiates from other interfaces.
	IsATEqualityContext()
}

type ATEqualityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATEqualityContext() *ATEqualityContext {
	var p = new(ATEqualityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTEquality
	return p
}

func InitEmptyATEqualityContext(p *ATEqualityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTEquality
}

func (*ATEqualityContext) IsATEqualityContext() {}

func NewATEqualityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATEqualityContext {
	var p = new(ATEqualityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTEquality

	return p
}

func (s *ATEqualityContext) GetParser() antlr.Parser { return s.parser }

func (s *ATEqualityContext) EQUALITY() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEQUALITY, 0)
}

func (s *ATEqualityContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *ATEqualityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATEqualityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATEqualityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATEquality(s)
	}
}

func (s *ATEqualityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATEquality(s)
	}
}

func (p *RFC4512Parser) ATEquality() (localctx IATEqualityContext) {
	localctx = NewATEqualityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, RFC4512ParserRULE_aTEquality)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(RFC4512ParserEQUALITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(587)
		p.OID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATOrderingContext is an interface to support dynamic dispatch.
type IATOrderingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDERING() antlr.TerminalNode
	OID() IOIDContext

	// IsATOrderingContext differentiates from other interfaces.
	IsATOrderingContext()
}

type ATOrderingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATOrderingContext() *ATOrderingContext {
	var p = new(ATOrderingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTOrdering
	return p
}

func InitEmptyATOrderingContext(p *ATOrderingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTOrdering
}

func (*ATOrderingContext) IsATOrderingContext() {}

func NewATOrderingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATOrderingContext {
	var p = new(ATOrderingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTOrdering

	return p
}

func (s *ATOrderingContext) GetParser() antlr.Parser { return s.parser }

func (s *ATOrderingContext) ORDERING() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserORDERING, 0)
}

func (s *ATOrderingContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *ATOrderingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATOrderingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATOrderingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATOrdering(s)
	}
}

func (s *ATOrderingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATOrdering(s)
	}
}

func (p *RFC4512Parser) ATOrdering() (localctx IATOrderingContext) {
	localctx = NewATOrderingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, RFC4512ParserRULE_aTOrdering)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.Match(RFC4512ParserORDERING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(590)
		p.OID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATSubstringContext is an interface to support dynamic dispatch.
type IATSubstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSTR() antlr.TerminalNode
	OID() IOIDContext

	// IsATSubstringContext differentiates from other interfaces.
	IsATSubstringContext()
}

type ATSubstringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATSubstringContext() *ATSubstringContext {
	var p = new(ATSubstringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTSubstring
	return p
}

func InitEmptyATSubstringContext(p *ATSubstringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTSubstring
}

func (*ATSubstringContext) IsATSubstringContext() {}

func NewATSubstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATSubstringContext {
	var p = new(ATSubstringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTSubstring

	return p
}

func (s *ATSubstringContext) GetParser() antlr.Parser { return s.parser }

func (s *ATSubstringContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSUBSTR, 0)
}

func (s *ATSubstringContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *ATSubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATSubstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATSubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATSubstring(s)
	}
}

func (s *ATSubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATSubstring(s)
	}
}

func (p *RFC4512Parser) ATSubstring() (localctx IATSubstringContext) {
	localctx = NewATSubstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, RFC4512ParserRULE_aTSubstring)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Match(RFC4512ParserSUBSTR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(593)
		p.OID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATSuperTypeContext is an interface to support dynamic dispatch.
type IATSuperTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUP() antlr.TerminalNode
	OID() IOIDContext

	// IsATSuperTypeContext differentiates from other interfaces.
	IsATSuperTypeContext()
}

type ATSuperTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATSuperTypeContext() *ATSuperTypeContext {
	var p = new(ATSuperTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTSuperType
	return p
}

func InitEmptyATSuperTypeContext(p *ATSuperTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTSuperType
}

func (*ATSuperTypeContext) IsATSuperTypeContext() {}

func NewATSuperTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATSuperTypeContext {
	var p = new(ATSuperTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTSuperType

	return p
}

func (s *ATSuperTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ATSuperTypeContext) SUP() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSUP, 0)
}

func (s *ATSuperTypeContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *ATSuperTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATSuperTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATSuperTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATSuperType(s)
	}
}

func (s *ATSuperTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATSuperType(s)
	}
}

func (p *RFC4512Parser) ATSuperType() (localctx IATSuperTypeContext) {
	localctx = NewATSuperTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, RFC4512ParserRULE_aTSuperType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(RFC4512ParserSUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(596)
		p.OID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATUsageContext is an interface to support dynamic dispatch.
type IATUsageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USAGE() antlr.TerminalNode
	Usage() antlr.TerminalNode

	// IsATUsageContext differentiates from other interfaces.
	IsATUsageContext()
}

type ATUsageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATUsageContext() *ATUsageContext {
	var p = new(ATUsageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTUsage
	return p
}

func InitEmptyATUsageContext(p *ATUsageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTUsage
}

func (*ATUsageContext) IsATUsageContext() {}

func NewATUsageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATUsageContext {
	var p = new(ATUsageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTUsage

	return p
}

func (s *ATUsageContext) GetParser() antlr.Parser { return s.parser }

func (s *ATUsageContext) USAGE() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserUSAGE, 0)
}

func (s *ATUsageContext) Usage() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserUsage, 0)
}

func (s *ATUsageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATUsageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATUsageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATUsage(s)
	}
}

func (s *ATUsageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATUsage(s)
	}
}

func (p *RFC4512Parser) ATUsage() (localctx IATUsageContext) {
	localctx = NewATUsageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, RFC4512ParserRULE_aTUsage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(RFC4512ParserUSAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(599)
		p.Match(RFC4512ParserUsage)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATSingleValueContext is an interface to support dynamic dispatch.
type IATSingleValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLEVAL() antlr.TerminalNode

	// IsATSingleValueContext differentiates from other interfaces.
	IsATSingleValueContext()
}

type ATSingleValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATSingleValueContext() *ATSingleValueContext {
	var p = new(ATSingleValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTSingleValue
	return p
}

func InitEmptyATSingleValueContext(p *ATSingleValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTSingleValue
}

func (*ATSingleValueContext) IsATSingleValueContext() {}

func NewATSingleValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATSingleValueContext {
	var p = new(ATSingleValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTSingleValue

	return p
}

func (s *ATSingleValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ATSingleValueContext) SINGLEVAL() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSINGLEVAL, 0)
}

func (s *ATSingleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATSingleValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATSingleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATSingleValue(s)
	}
}

func (s *ATSingleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATSingleValue(s)
	}
}

func (p *RFC4512Parser) ATSingleValue() (localctx IATSingleValueContext) {
	localctx = NewATSingleValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, RFC4512ParserRULE_aTSingleValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Match(RFC4512ParserSINGLEVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATCollectiveContext is an interface to support dynamic dispatch.
type IATCollectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLECTIVE() antlr.TerminalNode

	// IsATCollectiveContext differentiates from other interfaces.
	IsATCollectiveContext()
}

type ATCollectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATCollectiveContext() *ATCollectiveContext {
	var p = new(ATCollectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTCollective
	return p
}

func InitEmptyATCollectiveContext(p *ATCollectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTCollective
}

func (*ATCollectiveContext) IsATCollectiveContext() {}

func NewATCollectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATCollectiveContext {
	var p = new(ATCollectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTCollective

	return p
}

func (s *ATCollectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ATCollectiveContext) COLLECTIVE() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserCOLLECTIVE, 0)
}

func (s *ATCollectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATCollectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATCollectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATCollective(s)
	}
}

func (s *ATCollectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATCollective(s)
	}
}

func (p *RFC4512Parser) ATCollective() (localctx IATCollectiveContext) {
	localctx = NewATCollectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, RFC4512ParserRULE_aTCollective)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Match(RFC4512ParserCOLLECTIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IATNoUserModificationContext is an interface to support dynamic dispatch.
type IATNoUserModificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOMODS() antlr.TerminalNode

	// IsATNoUserModificationContext differentiates from other interfaces.
	IsATNoUserModificationContext()
}

type ATNoUserModificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyATNoUserModificationContext() *ATNoUserModificationContext {
	var p = new(ATNoUserModificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTNoUserModification
	return p
}

func InitEmptyATNoUserModificationContext(p *ATNoUserModificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_aTNoUserModification
}

func (*ATNoUserModificationContext) IsATNoUserModificationContext() {}

func NewATNoUserModificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ATNoUserModificationContext {
	var p = new(ATNoUserModificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_aTNoUserModification

	return p
}

func (s *ATNoUserModificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ATNoUserModificationContext) NOMODS() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNOMODS, 0)
}

func (s *ATNoUserModificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ATNoUserModificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ATNoUserModificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterATNoUserModification(s)
	}
}

func (s *ATNoUserModificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitATNoUserModification(s)
	}
}

func (p *RFC4512Parser) ATNoUserModification() (localctx IATNoUserModificationContext) {
	localctx = NewATNoUserModificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, RFC4512ParserRULE_aTNoUserModification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(RFC4512ParserNOMODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchingRuleDescriptionsContext is an interface to support dynamic dispatch.
type IMatchingRuleDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMRL() []antlr.TerminalNode
	MRL(i int) antlr.TerminalNode
	AllMatchingRuleDescription() []IMatchingRuleDescriptionContext
	MatchingRuleDescription(i int) IMatchingRuleDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsMatchingRuleDescriptionsContext differentiates from other interfaces.
	IsMatchingRuleDescriptionsContext()
}

type MatchingRuleDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchingRuleDescriptionsContext() *MatchingRuleDescriptionsContext {
	var p = new(MatchingRuleDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleDescriptions
	return p
}

func InitEmptyMatchingRuleDescriptionsContext(p *MatchingRuleDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleDescriptions
}

func (*MatchingRuleDescriptionsContext) IsMatchingRuleDescriptionsContext() {}

func NewMatchingRuleDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchingRuleDescriptionsContext {
	var p = new(MatchingRuleDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_matchingRuleDescriptions

	return p
}

func (s *MatchingRuleDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchingRuleDescriptionsContext) AllMRL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserMRL)
}

func (s *MatchingRuleDescriptionsContext) MRL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserMRL, i)
}

func (s *MatchingRuleDescriptionsContext) AllMatchingRuleDescription() []IMatchingRuleDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchingRuleDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IMatchingRuleDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchingRuleDescriptionContext); ok {
			tst[i] = t.(IMatchingRuleDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *MatchingRuleDescriptionsContext) MatchingRuleDescription(i int) IMatchingRuleDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchingRuleDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchingRuleDescriptionContext)
}

func (s *MatchingRuleDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *MatchingRuleDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *MatchingRuleDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *MatchingRuleDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *MatchingRuleDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *MatchingRuleDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *MatchingRuleDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchingRuleDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchingRuleDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMatchingRuleDescriptions(s)
	}
}

func (s *MatchingRuleDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMatchingRuleDescriptions(s)
	}
}

func (p *RFC4512Parser) MatchingRuleDescriptions() (localctx IMatchingRuleDescriptionsContext) {
	localctx = NewMatchingRuleDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, RFC4512ParserRULE_matchingRuleDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(607)
				p.Match(RFC4512ParserMRL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(608)
				p.MatchingRuleDescription()
			}
			p.SetState(612)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(609)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(614)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(615)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchingRuleDescriptionContext is an interface to support dynamic dispatch.
type IMatchingRuleDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	DefinitionSyntax() IDefinitionSyntaxContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsMatchingRuleDescriptionContext differentiates from other interfaces.
	IsMatchingRuleDescriptionContext()
}

type MatchingRuleDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchingRuleDescriptionContext() *MatchingRuleDescriptionContext {
	var p = new(MatchingRuleDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleDescription
	return p
}

func InitEmptyMatchingRuleDescriptionContext(p *MatchingRuleDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleDescription
}

func (*MatchingRuleDescriptionContext) IsMatchingRuleDescriptionContext() {}

func NewMatchingRuleDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchingRuleDescriptionContext {
	var p = new(MatchingRuleDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_matchingRuleDescription

	return p
}

func (s *MatchingRuleDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchingRuleDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *MatchingRuleDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *MatchingRuleDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *MatchingRuleDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *MatchingRuleDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *MatchingRuleDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *MatchingRuleDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *MatchingRuleDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *MatchingRuleDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *MatchingRuleDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *MatchingRuleDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *MatchingRuleDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *MatchingRuleDescriptionContext) DefinitionSyntax() IDefinitionSyntaxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionSyntaxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionSyntaxContext)
}

func (s *MatchingRuleDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *MatchingRuleDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchingRuleDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchingRuleDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMatchingRuleDescription(s)
	}
}

func (s *MatchingRuleDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMatchingRuleDescription(s)
	}
}

func (p *RFC4512Parser) MatchingRuleDescription() (localctx IMatchingRuleDescriptionContext) {
	localctx = NewMatchingRuleDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, RFC4512ParserRULE_matchingRuleDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.OpenParen()
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(622)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(628)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(631)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(634)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(640)
		p.NumericOIDOrMacro()
	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(641)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(647)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(650)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(653)
			p.DefinitionName()
		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(654)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(659)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(660)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(663)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(668)
			p.DefinitionDescription()
		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(669)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(676)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(675)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(678)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(683)
			p.DefinitionObsolete()
		}
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(684)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(689)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(691)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(690)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(693)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSYNTAX {
		{
			p.SetState(698)
			p.DefinitionSyntax()
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(699)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(704)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(705)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(709)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(708)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(713)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(716)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(722)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(725)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(728)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(734)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(737)
		p.CloseParen()
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(738)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchingRuleUseDescriptionsContext is an interface to support dynamic dispatch.
type IMatchingRuleUseDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMRUL() []antlr.TerminalNode
	MRUL(i int) antlr.TerminalNode
	AllMatchingRuleUseDescription() []IMatchingRuleUseDescriptionContext
	MatchingRuleUseDescription(i int) IMatchingRuleUseDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsMatchingRuleUseDescriptionsContext differentiates from other interfaces.
	IsMatchingRuleUseDescriptionsContext()
}

type MatchingRuleUseDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchingRuleUseDescriptionsContext() *MatchingRuleUseDescriptionsContext {
	var p = new(MatchingRuleUseDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleUseDescriptions
	return p
}

func InitEmptyMatchingRuleUseDescriptionsContext(p *MatchingRuleUseDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleUseDescriptions
}

func (*MatchingRuleUseDescriptionsContext) IsMatchingRuleUseDescriptionsContext() {}

func NewMatchingRuleUseDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchingRuleUseDescriptionsContext {
	var p = new(MatchingRuleUseDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_matchingRuleUseDescriptions

	return p
}

func (s *MatchingRuleUseDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchingRuleUseDescriptionsContext) AllMRUL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserMRUL)
}

func (s *MatchingRuleUseDescriptionsContext) MRUL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserMRUL, i)
}

func (s *MatchingRuleUseDescriptionsContext) AllMatchingRuleUseDescription() []IMatchingRuleUseDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchingRuleUseDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IMatchingRuleUseDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchingRuleUseDescriptionContext); ok {
			tst[i] = t.(IMatchingRuleUseDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *MatchingRuleUseDescriptionsContext) MatchingRuleUseDescription(i int) IMatchingRuleUseDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchingRuleUseDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchingRuleUseDescriptionContext)
}

func (s *MatchingRuleUseDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *MatchingRuleUseDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *MatchingRuleUseDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *MatchingRuleUseDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *MatchingRuleUseDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *MatchingRuleUseDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *MatchingRuleUseDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchingRuleUseDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchingRuleUseDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMatchingRuleUseDescriptions(s)
	}
}

func (s *MatchingRuleUseDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMatchingRuleUseDescriptions(s)
	}
}

func (p *RFC4512Parser) MatchingRuleUseDescriptions() (localctx IMatchingRuleUseDescriptionsContext) {
	localctx = NewMatchingRuleUseDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, RFC4512ParserRULE_matchingRuleUseDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(741)
				p.Match(RFC4512ParserMRUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(742)
				p.MatchingRuleUseDescription()
			}
			p.SetState(746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(743)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(748)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(749)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchingRuleUseDescriptionContext is an interface to support dynamic dispatch.
type IMatchingRuleUseDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	MRUApplies() IMRUAppliesContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsMatchingRuleUseDescriptionContext differentiates from other interfaces.
	IsMatchingRuleUseDescriptionContext()
}

type MatchingRuleUseDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchingRuleUseDescriptionContext() *MatchingRuleUseDescriptionContext {
	var p = new(MatchingRuleUseDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleUseDescription
	return p
}

func InitEmptyMatchingRuleUseDescriptionContext(p *MatchingRuleUseDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_matchingRuleUseDescription
}

func (*MatchingRuleUseDescriptionContext) IsMatchingRuleUseDescriptionContext() {}

func NewMatchingRuleUseDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchingRuleUseDescriptionContext {
	var p = new(MatchingRuleUseDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_matchingRuleUseDescription

	return p
}

func (s *MatchingRuleUseDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchingRuleUseDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *MatchingRuleUseDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *MatchingRuleUseDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *MatchingRuleUseDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *MatchingRuleUseDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *MatchingRuleUseDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *MatchingRuleUseDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *MatchingRuleUseDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *MatchingRuleUseDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *MatchingRuleUseDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *MatchingRuleUseDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *MatchingRuleUseDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *MatchingRuleUseDescriptionContext) MRUApplies() IMRUAppliesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMRUAppliesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMRUAppliesContext)
}

func (s *MatchingRuleUseDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *MatchingRuleUseDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchingRuleUseDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchingRuleUseDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMatchingRuleUseDescription(s)
	}
}

func (s *MatchingRuleUseDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMatchingRuleUseDescription(s)
	}
}

func (p *RFC4512Parser) MatchingRuleUseDescription() (localctx IMatchingRuleUseDescriptionContext) {
	localctx = NewMatchingRuleUseDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, RFC4512ParserRULE_matchingRuleUseDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.OpenParen()
	}
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(756)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(762)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(765)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(768)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(774)
		p.NumericOIDOrMacro()
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(775)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(781)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(784)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(787)
			p.DefinitionName()
		}
		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(788)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(793)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(794)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(798)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(797)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(802)
			p.DefinitionDescription()
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(803)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(808)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(809)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(813)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(812)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(817)
			p.DefinitionObsolete()
		}
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(818)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(823)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(825)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(824)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(827)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserAPPLIES {
		{
			p.SetState(832)
			p.MRUApplies()
		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(833)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(838)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(840)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(839)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(842)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(847)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(850)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(856)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(859)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(862)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(868)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(871)
		p.CloseParen()
	}
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(872)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMRUAppliesContext is an interface to support dynamic dispatch.
type IMRUAppliesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APPLIES() antlr.TerminalNode
	OID() IOIDContext
	OIDs() IOIDsContext

	// IsMRUAppliesContext differentiates from other interfaces.
	IsMRUAppliesContext()
}

type MRUAppliesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMRUAppliesContext() *MRUAppliesContext {
	var p = new(MRUAppliesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_mRUApplies
	return p
}

func InitEmptyMRUAppliesContext(p *MRUAppliesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_mRUApplies
}

func (*MRUAppliesContext) IsMRUAppliesContext() {}

func NewMRUAppliesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MRUAppliesContext {
	var p = new(MRUAppliesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_mRUApplies

	return p
}

func (s *MRUAppliesContext) GetParser() antlr.Parser { return s.parser }

func (s *MRUAppliesContext) APPLIES() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserAPPLIES, 0)
}

func (s *MRUAppliesContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *MRUAppliesContext) OIDs() IOIDsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDsContext)
}

func (s *MRUAppliesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MRUAppliesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MRUAppliesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMRUApplies(s)
	}
}

func (s *MRUAppliesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMRUApplies(s)
	}
}

func (p *RFC4512Parser) MRUApplies() (localctx IMRUAppliesContext) {
	localctx = NewMRUAppliesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, RFC4512ParserRULE_mRUApplies)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(RFC4512ParserAPPLIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserNumOID, RFC4512ParserDescr:
		{
			p.SetState(876)
			p.OID()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(877)
			p.OIDs()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPSyntaxDescriptionsContext is an interface to support dynamic dispatch.
type ILDAPSyntaxDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLSL() []antlr.TerminalNode
	LSL(i int) antlr.TerminalNode
	AllLDAPSyntaxDescription() []ILDAPSyntaxDescriptionContext
	LDAPSyntaxDescription(i int) ILDAPSyntaxDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsLDAPSyntaxDescriptionsContext differentiates from other interfaces.
	IsLDAPSyntaxDescriptionsContext()
}

type LDAPSyntaxDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPSyntaxDescriptionsContext() *LDAPSyntaxDescriptionsContext {
	var p = new(LDAPSyntaxDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_lDAPSyntaxDescriptions
	return p
}

func InitEmptyLDAPSyntaxDescriptionsContext(p *LDAPSyntaxDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_lDAPSyntaxDescriptions
}

func (*LDAPSyntaxDescriptionsContext) IsLDAPSyntaxDescriptionsContext() {}

func NewLDAPSyntaxDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPSyntaxDescriptionsContext {
	var p = new(LDAPSyntaxDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_lDAPSyntaxDescriptions

	return p
}

func (s *LDAPSyntaxDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPSyntaxDescriptionsContext) AllLSL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLSL)
}

func (s *LDAPSyntaxDescriptionsContext) LSL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLSL, i)
}

func (s *LDAPSyntaxDescriptionsContext) AllLDAPSyntaxDescription() []ILDAPSyntaxDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILDAPSyntaxDescriptionContext); ok {
			len++
		}
	}

	tst := make([]ILDAPSyntaxDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILDAPSyntaxDescriptionContext); ok {
			tst[i] = t.(ILDAPSyntaxDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *LDAPSyntaxDescriptionsContext) LDAPSyntaxDescription(i int) ILDAPSyntaxDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPSyntaxDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPSyntaxDescriptionContext)
}

func (s *LDAPSyntaxDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *LDAPSyntaxDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *LDAPSyntaxDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *LDAPSyntaxDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *LDAPSyntaxDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *LDAPSyntaxDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *LDAPSyntaxDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPSyntaxDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LDAPSyntaxDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterLDAPSyntaxDescriptions(s)
	}
}

func (s *LDAPSyntaxDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitLDAPSyntaxDescriptions(s)
	}
}

func (p *RFC4512Parser) LDAPSyntaxDescriptions() (localctx ILDAPSyntaxDescriptionsContext) {
	localctx = NewLDAPSyntaxDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, RFC4512ParserRULE_lDAPSyntaxDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(880)
				p.Match(RFC4512ParserLSL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(881)
				p.LDAPSyntaxDescription()
			}
			p.SetState(885)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(882)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(887)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(888)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPSyntaxDescriptionContext is an interface to support dynamic dispatch.
type ILDAPSyntaxDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsLDAPSyntaxDescriptionContext differentiates from other interfaces.
	IsLDAPSyntaxDescriptionContext()
}

type LDAPSyntaxDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPSyntaxDescriptionContext() *LDAPSyntaxDescriptionContext {
	var p = new(LDAPSyntaxDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_lDAPSyntaxDescription
	return p
}

func InitEmptyLDAPSyntaxDescriptionContext(p *LDAPSyntaxDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_lDAPSyntaxDescription
}

func (*LDAPSyntaxDescriptionContext) IsLDAPSyntaxDescriptionContext() {}

func NewLDAPSyntaxDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPSyntaxDescriptionContext {
	var p = new(LDAPSyntaxDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_lDAPSyntaxDescription

	return p
}

func (s *LDAPSyntaxDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPSyntaxDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *LDAPSyntaxDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *LDAPSyntaxDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *LDAPSyntaxDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *LDAPSyntaxDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *LDAPSyntaxDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *LDAPSyntaxDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *LDAPSyntaxDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *LDAPSyntaxDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *LDAPSyntaxDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *LDAPSyntaxDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *LDAPSyntaxDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPSyntaxDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LDAPSyntaxDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterLDAPSyntaxDescription(s)
	}
}

func (s *LDAPSyntaxDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitLDAPSyntaxDescription(s)
	}
}

func (p *RFC4512Parser) LDAPSyntaxDescription() (localctx ILDAPSyntaxDescriptionContext) {
	localctx = NewLDAPSyntaxDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, RFC4512ParserRULE_lDAPSyntaxDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		p.OpenParen()
	}
	p.SetState(898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(895)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(901)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(904)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(907)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(913)
		p.NumericOIDOrMacro()
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(914)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(920)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(923)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(926)
			p.DefinitionDescription()
		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(927)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(932)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(933)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(936)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(941)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(944)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(950)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(953)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(956)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(962)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(965)
		p.CloseParen()
	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(966)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDITContentRuleDescriptionsContext is an interface to support dynamic dispatch.
type IDITContentRuleDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDCRL() []antlr.TerminalNode
	DCRL(i int) antlr.TerminalNode
	AllDITContentRuleDescription() []IDITContentRuleDescriptionContext
	DITContentRuleDescription(i int) IDITContentRuleDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsDITContentRuleDescriptionsContext differentiates from other interfaces.
	IsDITContentRuleDescriptionsContext()
}

type DITContentRuleDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDITContentRuleDescriptionsContext() *DITContentRuleDescriptionsContext {
	var p = new(DITContentRuleDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITContentRuleDescriptions
	return p
}

func InitEmptyDITContentRuleDescriptionsContext(p *DITContentRuleDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITContentRuleDescriptions
}

func (*DITContentRuleDescriptionsContext) IsDITContentRuleDescriptionsContext() {}

func NewDITContentRuleDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DITContentRuleDescriptionsContext {
	var p = new(DITContentRuleDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dITContentRuleDescriptions

	return p
}

func (s *DITContentRuleDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DITContentRuleDescriptionsContext) AllDCRL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserDCRL)
}

func (s *DITContentRuleDescriptionsContext) DCRL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserDCRL, i)
}

func (s *DITContentRuleDescriptionsContext) AllDITContentRuleDescription() []IDITContentRuleDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDITContentRuleDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IDITContentRuleDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDITContentRuleDescriptionContext); ok {
			tst[i] = t.(IDITContentRuleDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *DITContentRuleDescriptionsContext) DITContentRuleDescription(i int) IDITContentRuleDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDITContentRuleDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDITContentRuleDescriptionContext)
}

func (s *DITContentRuleDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *DITContentRuleDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *DITContentRuleDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *DITContentRuleDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *DITContentRuleDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *DITContentRuleDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *DITContentRuleDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DITContentRuleDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DITContentRuleDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDITContentRuleDescriptions(s)
	}
}

func (s *DITContentRuleDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDITContentRuleDescriptions(s)
	}
}

func (p *RFC4512Parser) DITContentRuleDescriptions() (localctx IDITContentRuleDescriptionsContext) {
	localctx = NewDITContentRuleDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, RFC4512ParserRULE_dITContentRuleDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(969)
				p.Match(RFC4512ParserDCRL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(970)
				p.DITContentRuleDescription()
			}
			p.SetState(974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(971)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(976)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(977)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDITContentRuleDescriptionContext is an interface to support dynamic dispatch.
type IDITContentRuleDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	DCRAux() IDCRAuxContext
	DefinitionMust() IDefinitionMustContext
	DefinitionMay() IDefinitionMayContext
	DCRNot() IDCRNotContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsDITContentRuleDescriptionContext differentiates from other interfaces.
	IsDITContentRuleDescriptionContext()
}

type DITContentRuleDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDITContentRuleDescriptionContext() *DITContentRuleDescriptionContext {
	var p = new(DITContentRuleDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITContentRuleDescription
	return p
}

func InitEmptyDITContentRuleDescriptionContext(p *DITContentRuleDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITContentRuleDescription
}

func (*DITContentRuleDescriptionContext) IsDITContentRuleDescriptionContext() {}

func NewDITContentRuleDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DITContentRuleDescriptionContext {
	var p = new(DITContentRuleDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dITContentRuleDescription

	return p
}

func (s *DITContentRuleDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DITContentRuleDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *DITContentRuleDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *DITContentRuleDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *DITContentRuleDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *DITContentRuleDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *DITContentRuleDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *DITContentRuleDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *DITContentRuleDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *DITContentRuleDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *DITContentRuleDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *DITContentRuleDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *DITContentRuleDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *DITContentRuleDescriptionContext) DCRAux() IDCRAuxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDCRAuxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDCRAuxContext)
}

func (s *DITContentRuleDescriptionContext) DefinitionMust() IDefinitionMustContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionMustContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionMustContext)
}

func (s *DITContentRuleDescriptionContext) DefinitionMay() IDefinitionMayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionMayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionMayContext)
}

func (s *DITContentRuleDescriptionContext) DCRNot() IDCRNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDCRNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDCRNotContext)
}

func (s *DITContentRuleDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *DITContentRuleDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DITContentRuleDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DITContentRuleDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDITContentRuleDescription(s)
	}
}

func (s *DITContentRuleDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDITContentRuleDescription(s)
	}
}

func (p *RFC4512Parser) DITContentRuleDescription() (localctx IDITContentRuleDescriptionContext) {
	localctx = NewDITContentRuleDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, RFC4512ParserRULE_dITContentRuleDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)
		p.OpenParen()
	}
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(984)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(990)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(993)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(996)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1002)
		p.NumericOIDOrMacro()
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1003)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1009)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1012)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(1015)
			p.DefinitionName()
		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1016)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1021)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1023)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1022)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1025)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(1030)
			p.DefinitionDescription()
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1031)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1036)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1037)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1040)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(1045)
			p.DefinitionObsolete()
		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1046)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1051)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1052)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1055)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserAUX {
		{
			p.SetState(1060)
			p.DCRAux()
		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1061)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1066)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1067)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1070)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserMUST {
		{
			p.SetState(1075)
			p.DefinitionMust()
		}
		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1076)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1081)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1082)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1085)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserMAY {
		{
			p.SetState(1090)
			p.DefinitionMay()
		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1091)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1096)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1097)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1101)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1100)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNOT {
		{
			p.SetState(1105)
			p.DCRNot()
		}
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1106)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1111)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1113)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1112)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1115)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1120)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1123)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1129)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1132)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1135)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1141)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1144)
		p.CloseParen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDCRNotContext is an interface to support dynamic dispatch.
type IDCRNotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	OID() IOIDContext
	OIDs() IOIDsContext

	// IsDCRNotContext differentiates from other interfaces.
	IsDCRNotContext()
}

type DCRNotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDCRNotContext() *DCRNotContext {
	var p = new(DCRNotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dCRNot
	return p
}

func InitEmptyDCRNotContext(p *DCRNotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dCRNot
}

func (*DCRNotContext) IsDCRNotContext() {}

func NewDCRNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DCRNotContext {
	var p = new(DCRNotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dCRNot

	return p
}

func (s *DCRNotContext) GetParser() antlr.Parser { return s.parser }

func (s *DCRNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNOT, 0)
}

func (s *DCRNotContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *DCRNotContext) OIDs() IOIDsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDsContext)
}

func (s *DCRNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DCRNotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DCRNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDCRNot(s)
	}
}

func (s *DCRNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDCRNot(s)
	}
}

func (p *RFC4512Parser) DCRNot() (localctx IDCRNotContext) {
	localctx = NewDCRNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, RFC4512ParserRULE_dCRNot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Match(RFC4512ParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserNumOID, RFC4512ParserDescr:
		{
			p.SetState(1147)
			p.OID()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1148)
			p.OIDs()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDCRAuxContext is an interface to support dynamic dispatch.
type IDCRAuxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUX() antlr.TerminalNode
	OID() IOIDContext
	OIDs() IOIDsContext

	// IsDCRAuxContext differentiates from other interfaces.
	IsDCRAuxContext()
}

type DCRAuxContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDCRAuxContext() *DCRAuxContext {
	var p = new(DCRAuxContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dCRAux
	return p
}

func InitEmptyDCRAuxContext(p *DCRAuxContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dCRAux
}

func (*DCRAuxContext) IsDCRAuxContext() {}

func NewDCRAuxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DCRAuxContext {
	var p = new(DCRAuxContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dCRAux

	return p
}

func (s *DCRAuxContext) GetParser() antlr.Parser { return s.parser }

func (s *DCRAuxContext) AUX() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserAUX, 0)
}

func (s *DCRAuxContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *DCRAuxContext) OIDs() IOIDsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDsContext)
}

func (s *DCRAuxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DCRAuxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DCRAuxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDCRAux(s)
	}
}

func (s *DCRAuxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDCRAux(s)
	}
}

func (p *RFC4512Parser) DCRAux() (localctx IDCRAuxContext) {
	localctx = NewDCRAuxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, RFC4512ParserRULE_dCRAux)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Match(RFC4512ParserAUX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserNumOID, RFC4512ParserDescr:
		{
			p.SetState(1152)
			p.OID()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1153)
			p.OIDs()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDITStructureRuleDescriptionsContext is an interface to support dynamic dispatch.
type IDITStructureRuleDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDSRL() []antlr.TerminalNode
	DSRL(i int) antlr.TerminalNode
	AllDITStructureRuleDescription() []IDITStructureRuleDescriptionContext
	DITStructureRuleDescription(i int) IDITStructureRuleDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsDITStructureRuleDescriptionsContext differentiates from other interfaces.
	IsDITStructureRuleDescriptionsContext()
}

type DITStructureRuleDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDITStructureRuleDescriptionsContext() *DITStructureRuleDescriptionsContext {
	var p = new(DITStructureRuleDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITStructureRuleDescriptions
	return p
}

func InitEmptyDITStructureRuleDescriptionsContext(p *DITStructureRuleDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITStructureRuleDescriptions
}

func (*DITStructureRuleDescriptionsContext) IsDITStructureRuleDescriptionsContext() {}

func NewDITStructureRuleDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DITStructureRuleDescriptionsContext {
	var p = new(DITStructureRuleDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dITStructureRuleDescriptions

	return p
}

func (s *DITStructureRuleDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DITStructureRuleDescriptionsContext) AllDSRL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserDSRL)
}

func (s *DITStructureRuleDescriptionsContext) DSRL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserDSRL, i)
}

func (s *DITStructureRuleDescriptionsContext) AllDITStructureRuleDescription() []IDITStructureRuleDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDITStructureRuleDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IDITStructureRuleDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDITStructureRuleDescriptionContext); ok {
			tst[i] = t.(IDITStructureRuleDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *DITStructureRuleDescriptionsContext) DITStructureRuleDescription(i int) IDITStructureRuleDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDITStructureRuleDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDITStructureRuleDescriptionContext)
}

func (s *DITStructureRuleDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *DITStructureRuleDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *DITStructureRuleDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *DITStructureRuleDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *DITStructureRuleDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *DITStructureRuleDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *DITStructureRuleDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DITStructureRuleDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DITStructureRuleDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDITStructureRuleDescriptions(s)
	}
}

func (s *DITStructureRuleDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDITStructureRuleDescriptions(s)
	}
}

func (p *RFC4512Parser) DITStructureRuleDescriptions() (localctx IDITStructureRuleDescriptionsContext) {
	localctx = NewDITStructureRuleDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, RFC4512ParserRULE_dITStructureRuleDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1156)
				p.Match(RFC4512ParserDSRL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1157)
				p.DITStructureRuleDescription()
			}
			p.SetState(1161)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(1158)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1163)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1164)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1168)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDITStructureRuleDescriptionContext is an interface to support dynamic dispatch.
type IDITStructureRuleDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	StructureRule() IStructureRuleContext
	DSRForm() IDSRFormContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	DSRSuperRules() IDSRSuperRulesContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsDITStructureRuleDescriptionContext differentiates from other interfaces.
	IsDITStructureRuleDescriptionContext()
}

type DITStructureRuleDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDITStructureRuleDescriptionContext() *DITStructureRuleDescriptionContext {
	var p = new(DITStructureRuleDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITStructureRuleDescription
	return p
}

func InitEmptyDITStructureRuleDescriptionContext(p *DITStructureRuleDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dITStructureRuleDescription
}

func (*DITStructureRuleDescriptionContext) IsDITStructureRuleDescriptionContext() {}

func NewDITStructureRuleDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DITStructureRuleDescriptionContext {
	var p = new(DITStructureRuleDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dITStructureRuleDescription

	return p
}

func (s *DITStructureRuleDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DITStructureRuleDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *DITStructureRuleDescriptionContext) StructureRule() IStructureRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructureRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructureRuleContext)
}

func (s *DITStructureRuleDescriptionContext) DSRForm() IDSRFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDSRFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDSRFormContext)
}

func (s *DITStructureRuleDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *DITStructureRuleDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *DITStructureRuleDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *DITStructureRuleDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *DITStructureRuleDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *DITStructureRuleDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *DITStructureRuleDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *DITStructureRuleDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *DITStructureRuleDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *DITStructureRuleDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *DITStructureRuleDescriptionContext) DSRSuperRules() IDSRSuperRulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDSRSuperRulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDSRSuperRulesContext)
}

func (s *DITStructureRuleDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *DITStructureRuleDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DITStructureRuleDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DITStructureRuleDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDITStructureRuleDescription(s)
	}
}

func (s *DITStructureRuleDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDITStructureRuleDescription(s)
	}
}

func (p *RFC4512Parser) DITStructureRuleDescription() (localctx IDITStructureRuleDescriptionContext) {
	localctx = NewDITStructureRuleDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, RFC4512ParserRULE_dITStructureRuleDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1170)
		p.OpenParen()
	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1171)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1177)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1180)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1183)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1189)
		p.StructureRule()
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1190)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1196)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1199)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(1202)
			p.DefinitionName()
		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1203)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1208)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1209)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1212)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(1217)
			p.DefinitionDescription()
		}
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1218)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1223)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1224)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1227)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(1232)
			p.DefinitionObsolete()
		}
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1233)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1238)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1239)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1242)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1247)
		p.DSRForm()
	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1248)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1254)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1257)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserSUP {
		{
			p.SetState(1260)
			p.DSRSuperRules()
		}
		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1261)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1266)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1267)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1271)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1270)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1276)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1275)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1278)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1284)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1287)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1290)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1295)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1296)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1299)
		p.CloseParen()
	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1300)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructureRulesContext is an interface to support dynamic dispatch.
type IStructureRulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	AllStructureRule() []IStructureRuleContext
	StructureRule(i int) IStructureRuleContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsStructureRulesContext differentiates from other interfaces.
	IsStructureRulesContext()
}

type StructureRulesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructureRulesContext() *StructureRulesContext {
	var p = new(StructureRulesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_structureRules
	return p
}

func InitEmptyStructureRulesContext(p *StructureRulesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_structureRules
}

func (*StructureRulesContext) IsStructureRulesContext() {}

func NewStructureRulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructureRulesContext {
	var p = new(StructureRulesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_structureRules

	return p
}

func (s *StructureRulesContext) GetParser() antlr.Parser { return s.parser }

func (s *StructureRulesContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *StructureRulesContext) AllStructureRule() []IStructureRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructureRuleContext); ok {
			len++
		}
	}

	tst := make([]IStructureRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructureRuleContext); ok {
			tst[i] = t.(IStructureRuleContext)
			i++
		}
	}

	return tst
}

func (s *StructureRulesContext) StructureRule(i int) IStructureRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructureRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructureRuleContext)
}

func (s *StructureRulesContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *StructureRulesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *StructureRulesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *StructureRulesContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *StructureRulesContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *StructureRulesContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *StructureRulesContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *StructureRulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructureRulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructureRulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterStructureRules(s)
	}
}

func (s *StructureRulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitStructureRules(s)
	}
}

func (p *RFC4512Parser) StructureRules() (localctx IStructureRulesContext) {
	localctx = NewStructureRulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, RFC4512ParserRULE_structureRules)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1303)
		p.OpenParen()
	}
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1304)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1310)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1313)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1316)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1322)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1325)
		p.StructureRule()
	}
	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1326)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1332)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1335)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1339)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == RFC4512ParserSP {
				{
					p.SetState(1338)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1341)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1343)
				p.StructureRule()
			}

		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1349)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1355)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1358)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1361)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1367)
		p.CloseParen()
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1368)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1374)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDSRSuperRulesContext is an interface to support dynamic dispatch.
type IDSRSuperRulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUP() antlr.TerminalNode
	StructureRule() IStructureRuleContext
	StructureRules() IStructureRulesContext

	// IsDSRSuperRulesContext differentiates from other interfaces.
	IsDSRSuperRulesContext()
}

type DSRSuperRulesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDSRSuperRulesContext() *DSRSuperRulesContext {
	var p = new(DSRSuperRulesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dSRSuperRules
	return p
}

func InitEmptyDSRSuperRulesContext(p *DSRSuperRulesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dSRSuperRules
}

func (*DSRSuperRulesContext) IsDSRSuperRulesContext() {}

func NewDSRSuperRulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DSRSuperRulesContext {
	var p = new(DSRSuperRulesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dSRSuperRules

	return p
}

func (s *DSRSuperRulesContext) GetParser() antlr.Parser { return s.parser }

func (s *DSRSuperRulesContext) SUP() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSUP, 0)
}

func (s *DSRSuperRulesContext) StructureRule() IStructureRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructureRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructureRuleContext)
}

func (s *DSRSuperRulesContext) StructureRules() IStructureRulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructureRulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructureRulesContext)
}

func (s *DSRSuperRulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DSRSuperRulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DSRSuperRulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDSRSuperRules(s)
	}
}

func (s *DSRSuperRulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDSRSuperRules(s)
	}
}

func (p *RFC4512Parser) DSRSuperRules() (localctx IDSRSuperRulesContext) {
	localctx = NewDSRSuperRulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, RFC4512ParserRULE_dSRSuperRules)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.Match(RFC4512ParserSUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserDigit:
		{
			p.SetState(1378)
			p.StructureRule()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1379)
			p.StructureRules()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructureRuleContext is an interface to support dynamic dispatch.
type IStructureRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsStructureRuleContext differentiates from other interfaces.
	IsStructureRuleContext()
}

type StructureRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructureRuleContext() *StructureRuleContext {
	var p = new(StructureRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_structureRule
	return p
}

func InitEmptyStructureRuleContext(p *StructureRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_structureRule
}

func (*StructureRuleContext) IsStructureRuleContext() {}

func NewStructureRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructureRuleContext {
	var p = new(StructureRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_structureRule

	return p
}

func (s *StructureRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *StructureRuleContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *StructureRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructureRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructureRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterStructureRule(s)
	}
}

func (s *StructureRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitStructureRule(s)
	}
}

func (p *RFC4512Parser) StructureRule() (localctx IStructureRuleContext) {
	localctx = NewStructureRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, RFC4512ParserRULE_structureRule)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDSRFormContext is an interface to support dynamic dispatch.
type IDSRFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORM() antlr.TerminalNode
	OID() IOIDContext

	// IsDSRFormContext differentiates from other interfaces.
	IsDSRFormContext()
}

type DSRFormContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDSRFormContext() *DSRFormContext {
	var p = new(DSRFormContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dSRForm
	return p
}

func InitEmptyDSRFormContext(p *DSRFormContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_dSRForm
}

func (*DSRFormContext) IsDSRFormContext() {}

func NewDSRFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DSRFormContext {
	var p = new(DSRFormContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_dSRForm

	return p
}

func (s *DSRFormContext) GetParser() antlr.Parser { return s.parser }

func (s *DSRFormContext) FORM() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserFORM, 0)
}

func (s *DSRFormContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *DSRFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DSRFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DSRFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDSRForm(s)
	}
}

func (s *DSRFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDSRForm(s)
	}
}

func (p *RFC4512Parser) DSRForm() (localctx IDSRFormContext) {
	localctx = NewDSRFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, RFC4512ParserRULE_dSRForm)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1384)
		p.Match(RFC4512ParserFORM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1385)
		p.OID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameFormDescriptionsContext is an interface to support dynamic dispatch.
type INameFormDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNFL() []antlr.TerminalNode
	NFL(i int) antlr.TerminalNode
	AllNameFormDescription() []INameFormDescriptionContext
	NameFormDescription(i int) INameFormDescriptionContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllEOF() []antlr.TerminalNode
	EOF(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode

	// IsNameFormDescriptionsContext differentiates from other interfaces.
	IsNameFormDescriptionsContext()
}

type NameFormDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameFormDescriptionsContext() *NameFormDescriptionsContext {
	var p = new(NameFormDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_nameFormDescriptions
	return p
}

func InitEmptyNameFormDescriptionsContext(p *NameFormDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_nameFormDescriptions
}

func (*NameFormDescriptionsContext) IsNameFormDescriptionsContext() {}

func NewNameFormDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameFormDescriptionsContext {
	var p = new(NameFormDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_nameFormDescriptions

	return p
}

func (s *NameFormDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *NameFormDescriptionsContext) AllNFL() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNFL)
}

func (s *NameFormDescriptionsContext) NFL(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNFL, i)
}

func (s *NameFormDescriptionsContext) AllNameFormDescription() []INameFormDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameFormDescriptionContext); ok {
			len++
		}
	}

	tst := make([]INameFormDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameFormDescriptionContext); ok {
			tst[i] = t.(INameFormDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *NameFormDescriptionsContext) NameFormDescription(i int) INameFormDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameFormDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameFormDescriptionContext)
}

func (s *NameFormDescriptionsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *NameFormDescriptionsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *NameFormDescriptionsContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserEOF)
}

func (s *NameFormDescriptionsContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserEOF, i)
}

func (s *NameFormDescriptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *NameFormDescriptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *NameFormDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameFormDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameFormDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterNameFormDescriptions(s)
	}
}

func (s *NameFormDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitNameFormDescriptions(s)
	}
}

func (p *RFC4512Parser) NameFormDescriptions() (localctx INameFormDescriptionsContext) {
	localctx = NewNameFormDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, RFC4512ParserRULE_nameFormDescriptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1387)
				p.Match(RFC4512ParserNFL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1388)
				p.NameFormDescription()
			}
			p.SetState(1392)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == RFC4512ParserSP {
				{
					p.SetState(1389)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1394)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1395)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC4512ParserEOF || _la == RFC4512ParserNEWLINE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameFormDescriptionContext is an interface to support dynamic dispatch.
type INameFormDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	NumericOIDOrMacro() INumericOIDOrMacroContext
	NFStructuralOC() INFStructuralOCContext
	DefinitionMust() IDefinitionMustContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DefinitionName() IDefinitionNameContext
	DefinitionDescription() IDefinitionDescriptionContext
	DefinitionObsolete() IDefinitionObsoleteContext
	DefinitionMay() IDefinitionMayContext
	DefinitionExtensions() IDefinitionExtensionsContext

	// IsNameFormDescriptionContext differentiates from other interfaces.
	IsNameFormDescriptionContext()
}

type NameFormDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameFormDescriptionContext() *NameFormDescriptionContext {
	var p = new(NameFormDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_nameFormDescription
	return p
}

func InitEmptyNameFormDescriptionContext(p *NameFormDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_nameFormDescription
}

func (*NameFormDescriptionContext) IsNameFormDescriptionContext() {}

func NewNameFormDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameFormDescriptionContext {
	var p = new(NameFormDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_nameFormDescription

	return p
}

func (s *NameFormDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *NameFormDescriptionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *NameFormDescriptionContext) NumericOIDOrMacro() INumericOIDOrMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDOrMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDOrMacroContext)
}

func (s *NameFormDescriptionContext) NFStructuralOC() INFStructuralOCContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INFStructuralOCContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INFStructuralOCContext)
}

func (s *NameFormDescriptionContext) DefinitionMust() IDefinitionMustContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionMustContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionMustContext)
}

func (s *NameFormDescriptionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *NameFormDescriptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *NameFormDescriptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *NameFormDescriptionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *NameFormDescriptionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *NameFormDescriptionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *NameFormDescriptionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *NameFormDescriptionContext) DefinitionName() IDefinitionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionNameContext)
}

func (s *NameFormDescriptionContext) DefinitionDescription() IDefinitionDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionDescriptionContext)
}

func (s *NameFormDescriptionContext) DefinitionObsolete() IDefinitionObsoleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionObsoleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionObsoleteContext)
}

func (s *NameFormDescriptionContext) DefinitionMay() IDefinitionMayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionMayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionMayContext)
}

func (s *NameFormDescriptionContext) DefinitionExtensions() IDefinitionExtensionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionsContext)
}

func (s *NameFormDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameFormDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameFormDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterNameFormDescription(s)
	}
}

func (s *NameFormDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitNameFormDescription(s)
	}
}

func (p *RFC4512Parser) NameFormDescription() (localctx INameFormDescriptionContext) {
	localctx = NewNameFormDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, RFC4512ParserRULE_nameFormDescription)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1401)
		p.OpenParen()
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1402)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1408)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1411)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1414)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1420)
		p.NumericOIDOrMacro()
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1421)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1427)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1430)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNAME {
		{
			p.SetState(1433)
			p.DefinitionName()
		}
		p.SetState(1437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1434)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1439)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1440)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1443)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserDESC {
		{
			p.SetState(1448)
			p.DefinitionDescription()
		}
		p.SetState(1452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1449)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1455)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1458)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserOBSOLETE {
		{
			p.SetState(1463)
			p.DefinitionObsolete()
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1464)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1469)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1470)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1473)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1478)
		p.NFStructuralOC()
	}
	p.SetState(1482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1479)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1485)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1488)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1491)
		p.DefinitionMust()
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1492)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1498)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1502)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1501)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserMAY {
		{
			p.SetState(1504)
			p.DefinitionMay()
		}
		p.SetState(1508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1505)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1511)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1514)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1519)
			p.DefinitionExtensions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1522)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1528)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1531)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1534)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1540)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1543)
		p.CloseParen()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1544)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INFStructuralOCContext is an interface to support dynamic dispatch.
type INFStructuralOCContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OC() antlr.TerminalNode
	OID() IOIDContext

	// IsNFStructuralOCContext differentiates from other interfaces.
	IsNFStructuralOCContext()
}

type NFStructuralOCContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNFStructuralOCContext() *NFStructuralOCContext {
	var p = new(NFStructuralOCContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_nFStructuralOC
	return p
}

func InitEmptyNFStructuralOCContext(p *NFStructuralOCContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_nFStructuralOC
}

func (*NFStructuralOCContext) IsNFStructuralOCContext() {}

func NewNFStructuralOCContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NFStructuralOCContext {
	var p = new(NFStructuralOCContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_nFStructuralOC

	return p
}

func (s *NFStructuralOCContext) GetParser() antlr.Parser { return s.parser }

func (s *NFStructuralOCContext) OC() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserOC, 0)
}

func (s *NFStructuralOCContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *NFStructuralOCContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NFStructuralOCContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NFStructuralOCContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterNFStructuralOC(s)
	}
}

func (s *NFStructuralOCContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitNFStructuralOC(s)
	}
}

func (p *RFC4512Parser) NFStructuralOC() (localctx INFStructuralOCContext) {
	localctx = NewNFStructuralOCContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, RFC4512ParserRULE_nFStructuralOC)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1547)
		p.Match(RFC4512ParserOC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1548)
		p.OID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionObsoleteContext is an interface to support dynamic dispatch.
type IDefinitionObsoleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBSOLETE() antlr.TerminalNode

	// IsDefinitionObsoleteContext differentiates from other interfaces.
	IsDefinitionObsoleteContext()
}

type DefinitionObsoleteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionObsoleteContext() *DefinitionObsoleteContext {
	var p = new(DefinitionObsoleteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionObsolete
	return p
}

func InitEmptyDefinitionObsoleteContext(p *DefinitionObsoleteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionObsolete
}

func (*DefinitionObsoleteContext) IsDefinitionObsoleteContext() {}

func NewDefinitionObsoleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionObsoleteContext {
	var p = new(DefinitionObsoleteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionObsolete

	return p
}

func (s *DefinitionObsoleteContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionObsoleteContext) OBSOLETE() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserOBSOLETE, 0)
}

func (s *DefinitionObsoleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionObsoleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionObsoleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionObsolete(s)
	}
}

func (s *DefinitionObsoleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionObsolete(s)
	}
}

func (p *RFC4512Parser) DefinitionObsolete() (localctx IDefinitionObsoleteContext) {
	localctx = NewDefinitionObsoleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, RFC4512ParserRULE_definitionObsolete)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.Match(RFC4512ParserOBSOLETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionSyntaxContext is an interface to support dynamic dispatch.
type IDefinitionSyntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYNTAX() antlr.TerminalNode
	NumericOID() INumericOIDContext

	// IsDefinitionSyntaxContext differentiates from other interfaces.
	IsDefinitionSyntaxContext()
}

type DefinitionSyntaxContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionSyntaxContext() *DefinitionSyntaxContext {
	var p = new(DefinitionSyntaxContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionSyntax
	return p
}

func InitEmptyDefinitionSyntaxContext(p *DefinitionSyntaxContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionSyntax
}

func (*DefinitionSyntaxContext) IsDefinitionSyntaxContext() {}

func NewDefinitionSyntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionSyntaxContext {
	var p = new(DefinitionSyntaxContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionSyntax

	return p
}

func (s *DefinitionSyntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionSyntaxContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSYNTAX, 0)
}

func (s *DefinitionSyntaxContext) NumericOID() INumericOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDContext)
}

func (s *DefinitionSyntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionSyntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionSyntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionSyntax(s)
	}
}

func (s *DefinitionSyntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionSyntax(s)
	}
}

func (p *RFC4512Parser) DefinitionSyntax() (localctx IDefinitionSyntaxContext) {
	localctx = NewDefinitionSyntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, RFC4512ParserRULE_definitionSyntax)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.Match(RFC4512ParserSYNTAX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1553)
		p.NumericOID()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionMustContext is an interface to support dynamic dispatch.
type IDefinitionMustContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MUST() antlr.TerminalNode
	OID() IOIDContext
	OIDs() IOIDsContext

	// IsDefinitionMustContext differentiates from other interfaces.
	IsDefinitionMustContext()
}

type DefinitionMustContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionMustContext() *DefinitionMustContext {
	var p = new(DefinitionMustContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionMust
	return p
}

func InitEmptyDefinitionMustContext(p *DefinitionMustContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionMust
}

func (*DefinitionMustContext) IsDefinitionMustContext() {}

func NewDefinitionMustContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionMustContext {
	var p = new(DefinitionMustContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionMust

	return p
}

func (s *DefinitionMustContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionMustContext) MUST() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserMUST, 0)
}

func (s *DefinitionMustContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *DefinitionMustContext) OIDs() IOIDsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDsContext)
}

func (s *DefinitionMustContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionMustContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionMustContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionMust(s)
	}
}

func (s *DefinitionMustContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionMust(s)
	}
}

func (p *RFC4512Parser) DefinitionMust() (localctx IDefinitionMustContext) {
	localctx = NewDefinitionMustContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, RFC4512ParserRULE_definitionMust)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1555)
		p.Match(RFC4512ParserMUST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserNumOID, RFC4512ParserDescr:
		{
			p.SetState(1556)
			p.OID()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1557)
			p.OIDs()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionMayContext is an interface to support dynamic dispatch.
type IDefinitionMayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAY() antlr.TerminalNode
	OID() IOIDContext
	OIDs() IOIDsContext

	// IsDefinitionMayContext differentiates from other interfaces.
	IsDefinitionMayContext()
}

type DefinitionMayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionMayContext() *DefinitionMayContext {
	var p = new(DefinitionMayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionMay
	return p
}

func InitEmptyDefinitionMayContext(p *DefinitionMayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionMay
}

func (*DefinitionMayContext) IsDefinitionMayContext() {}

func NewDefinitionMayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionMayContext {
	var p = new(DefinitionMayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionMay

	return p
}

func (s *DefinitionMayContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionMayContext) MAY() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserMAY, 0)
}

func (s *DefinitionMayContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *DefinitionMayContext) OIDs() IOIDsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDsContext)
}

func (s *DefinitionMayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionMayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionMayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionMay(s)
	}
}

func (s *DefinitionMayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionMay(s)
	}
}

func (p *RFC4512Parser) DefinitionMay() (localctx IDefinitionMayContext) {
	localctx = NewDefinitionMayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, RFC4512ParserRULE_definitionMay)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1560)
		p.Match(RFC4512ParserMAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserNumOID, RFC4512ParserDescr:
		{
			p.SetState(1561)
			p.OID()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1562)
			p.OIDs()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionDescriptionContext is an interface to support dynamic dispatch.
type IDefinitionDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESC() antlr.TerminalNode
	QuotedString() antlr.TerminalNode
	QuotedDescriptor() antlr.TerminalNode

	// IsDefinitionDescriptionContext differentiates from other interfaces.
	IsDefinitionDescriptionContext()
}

type DefinitionDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionDescriptionContext() *DefinitionDescriptionContext {
	var p = new(DefinitionDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionDescription
	return p
}

func InitEmptyDefinitionDescriptionContext(p *DefinitionDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionDescription
}

func (*DefinitionDescriptionContext) IsDefinitionDescriptionContext() {}

func NewDefinitionDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionDescriptionContext {
	var p = new(DefinitionDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionDescription

	return p
}

func (s *DefinitionDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionDescriptionContext) DESC() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserDESC, 0)
}

func (s *DefinitionDescriptionContext) QuotedString() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserQuotedString, 0)
}

func (s *DefinitionDescriptionContext) QuotedDescriptor() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserQuotedDescriptor, 0)
}

func (s *DefinitionDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionDescription(s)
	}
}

func (s *DefinitionDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionDescription(s)
	}
}

func (p *RFC4512Parser) DefinitionDescription() (localctx IDefinitionDescriptionContext) {
	localctx = NewDefinitionDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, RFC4512ParserRULE_definitionDescription)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		p.Match(RFC4512ParserDESC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1566)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RFC4512ParserQuotedDescriptor || _la == RFC4512ParserQuotedString) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionNameContext is an interface to support dynamic dispatch.
type IDefinitionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	AllQuotedDescriptor() []antlr.TerminalNode
	QuotedDescriptor(i int) antlr.TerminalNode
	OpenParen() IOpenParenContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsDefinitionNameContext differentiates from other interfaces.
	IsDefinitionNameContext()
}

type DefinitionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionNameContext() *DefinitionNameContext {
	var p = new(DefinitionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionName
	return p
}

func InitEmptyDefinitionNameContext(p *DefinitionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionName
}

func (*DefinitionNameContext) IsDefinitionNameContext() {}

func NewDefinitionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionNameContext {
	var p = new(DefinitionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionName

	return p
}

func (s *DefinitionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNAME, 0)
}

func (s *DefinitionNameContext) AllQuotedDescriptor() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserQuotedDescriptor)
}

func (s *DefinitionNameContext) QuotedDescriptor(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserQuotedDescriptor, i)
}

func (s *DefinitionNameContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *DefinitionNameContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *DefinitionNameContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *DefinitionNameContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *DefinitionNameContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *DefinitionNameContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *DefinitionNameContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *DefinitionNameContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *DefinitionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionName(s)
	}
}

func (s *DefinitionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionName(s)
	}
}

func (p *RFC4512Parser) DefinitionName() (localctx IDefinitionNameContext) {
	localctx = NewDefinitionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, RFC4512ParserRULE_definitionName)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		p.Match(RFC4512ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserQuotedDescriptor:
		{
			p.SetState(1569)
			p.Match(RFC4512ParserQuotedDescriptor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1570)
			p.OpenParen()
		}
		p.SetState(1574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1571)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1576)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1578)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1577)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1580)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1583)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1588)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1589)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1592)
			p.Match(RFC4512ParserQuotedDescriptor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1593)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1598)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1600)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1599)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1603)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1602)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1606)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == RFC4512ParserSP {
					{
						p.SetState(1605)
						p.Match(RFC4512ParserSP)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(1608)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1610)
					p.Match(RFC4512ParserQuotedDescriptor)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1615)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1616)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1621)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1622)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1625)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1628)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1633)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1634)
			p.CloseParen()
		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1635)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1640)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1642)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1641)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionExtensionsContext is an interface to support dynamic dispatch.
type IDefinitionExtensionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDefinitionExtension() []IDefinitionExtensionContext
	DefinitionExtension(i int) IDefinitionExtensionContext

	// IsDefinitionExtensionsContext differentiates from other interfaces.
	IsDefinitionExtensionsContext()
}

type DefinitionExtensionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionExtensionsContext() *DefinitionExtensionsContext {
	var p = new(DefinitionExtensionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionExtensions
	return p
}

func InitEmptyDefinitionExtensionsContext(p *DefinitionExtensionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionExtensions
}

func (*DefinitionExtensionsContext) IsDefinitionExtensionsContext() {}

func NewDefinitionExtensionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionExtensionsContext {
	var p = new(DefinitionExtensionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionExtensions

	return p
}

func (s *DefinitionExtensionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionExtensionsContext) AllDefinitionExtension() []IDefinitionExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefinitionExtensionContext); ok {
			len++
		}
	}

	tst := make([]IDefinitionExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefinitionExtensionContext); ok {
			tst[i] = t.(IDefinitionExtensionContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionExtensionsContext) DefinitionExtension(i int) IDefinitionExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionExtensionContext)
}

func (s *DefinitionExtensionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionExtensionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionExtensionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionExtensions(s)
	}
}

func (s *DefinitionExtensionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionExtensions(s)
	}
}

func (p *RFC4512Parser) DefinitionExtensions() (localctx IDefinitionExtensionsContext) {
	localctx = NewDefinitionExtensionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, RFC4512ParserRULE_definitionExtensions)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1646)
				p.DefinitionExtension()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1649)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitionExtensionContext is an interface to support dynamic dispatch.
type IDefinitionExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExtensionName() antlr.TerminalNode
	AllExtensionValue() []IExtensionValueContext
	ExtensionValue(i int) IExtensionValueContext
	OpenParen() IOpenParenContext
	CloseParen() ICloseParenContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode

	// IsDefinitionExtensionContext differentiates from other interfaces.
	IsDefinitionExtensionContext()
}

type DefinitionExtensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionExtensionContext() *DefinitionExtensionContext {
	var p = new(DefinitionExtensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionExtension
	return p
}

func InitEmptyDefinitionExtensionContext(p *DefinitionExtensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_definitionExtension
}

func (*DefinitionExtensionContext) IsDefinitionExtensionContext() {}

func NewDefinitionExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionExtensionContext {
	var p = new(DefinitionExtensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_definitionExtension

	return p
}

func (s *DefinitionExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionExtensionContext) ExtensionName() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserExtensionName, 0)
}

func (s *DefinitionExtensionContext) AllExtensionValue() []IExtensionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExtensionValueContext); ok {
			len++
		}
	}

	tst := make([]IExtensionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExtensionValueContext); ok {
			tst[i] = t.(IExtensionValueContext)
			i++
		}
	}

	return tst
}

func (s *DefinitionExtensionContext) ExtensionValue(i int) IExtensionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensionValueContext)
}

func (s *DefinitionExtensionContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *DefinitionExtensionContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *DefinitionExtensionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *DefinitionExtensionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *DefinitionExtensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *DefinitionExtensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *DefinitionExtensionContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *DefinitionExtensionContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *DefinitionExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDefinitionExtension(s)
	}
}

func (s *DefinitionExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDefinitionExtension(s)
	}
}

func (p *RFC4512Parser) DefinitionExtension() (localctx IDefinitionExtensionContext) {
	localctx = NewDefinitionExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, RFC4512ParserRULE_definitionExtension)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1651)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1654)
		p.Match(RFC4512ParserExtensionName)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserQuotedDescriptor, RFC4512ParserQuotedString:
		{
			p.SetState(1655)
			p.ExtensionValue()
		}

	case RFC4512ParserOpenParenthesis:
		{
			p.SetState(1656)
			p.OpenParen()
		}
		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1657)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1662)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1663)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1666)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1669)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1675)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1678)
			p.ExtensionValue()
		}
		p.SetState(1682)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1679)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1684)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1685)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1689)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1688)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1692)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == RFC4512ParserSP {
					{
						p.SetState(1691)
						p.Match(RFC4512ParserSP)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(1694)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1696)
					p.ExtensionValue()
				}

			}
			p.SetState(1701)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1702)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserLineComment {
			{
				p.SetState(1708)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == RFC4512ParserNEWLINE {
			{
				p.SetState(1711)
				p.Match(RFC4512ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1714)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1719)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1720)
			p.CloseParen()
		}
		p.SetState(1724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1721)
					p.Match(RFC4512ParserSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1726)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1728)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1727)
				p.Match(RFC4512ParserLineComment)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOIDsContext is an interface to support dynamic dispatch.
type IOIDsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() IOpenParenContext
	AllOID() []IOIDContext
	OID(i int) IOIDContext
	CloseParen() ICloseParenContext
	AllSP() []antlr.TerminalNode
	SP(i int) antlr.TerminalNode
	AllLineComment() []antlr.TerminalNode
	LineComment(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllODelim() []antlr.TerminalNode
	ODelim(i int) antlr.TerminalNode

	// IsOIDsContext differentiates from other interfaces.
	IsOIDsContext()
}

type OIDsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOIDsContext() *OIDsContext {
	var p = new(OIDsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oIDs
	return p
}

func InitEmptyOIDsContext(p *OIDsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oIDs
}

func (*OIDsContext) IsOIDsContext() {}

func NewOIDsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OIDsContext {
	var p = new(OIDsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_oIDs

	return p
}

func (s *OIDsContext) GetParser() antlr.Parser { return s.parser }

func (s *OIDsContext) OpenParen() IOpenParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenParenContext)
}

func (s *OIDsContext) AllOID() []IOIDContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOIDContext); ok {
			len++
		}
	}

	tst := make([]IOIDContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOIDContext); ok {
			tst[i] = t.(IOIDContext)
			i++
		}
	}

	return tst
}

func (s *OIDsContext) OID(i int) IOIDContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *OIDsContext) CloseParen() ICloseParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseParenContext)
}

func (s *OIDsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserSP)
}

func (s *OIDsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserSP, i)
}

func (s *OIDsContext) AllLineComment() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserLineComment)
}

func (s *OIDsContext) LineComment(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserLineComment, i)
}

func (s *OIDsContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserNEWLINE)
}

func (s *OIDsContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNEWLINE, i)
}

func (s *OIDsContext) AllODelim() []antlr.TerminalNode {
	return s.GetTokens(RFC4512ParserODelim)
}

func (s *OIDsContext) ODelim(i int) antlr.TerminalNode {
	return s.GetToken(RFC4512ParserODelim, i)
}

func (s *OIDsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OIDsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OIDsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterOIDs(s)
	}
}

func (s *OIDsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitOIDs(s)
	}
}

func (p *RFC4512Parser) OIDs() (localctx IOIDsContext) {
	localctx = NewOIDsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, RFC4512ParserRULE_oIDs)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1732)
		p.OpenParen()
	}
	p.SetState(1736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1733)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1739)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1742)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1745)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1751)
		p.OID()
	}
	p.SetState(1755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1752)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1759)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1758)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1762)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1761)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserODelim {
		{
			p.SetState(1764)
			p.Match(RFC4512ParserODelim)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == RFC4512ParserSP {
			{
				p.SetState(1765)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1770)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1771)
			p.OID()
		}

		p.SetState(1776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 379, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1777)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 379, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1784)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1783)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserNEWLINE {
		{
			p.SetState(1786)
			p.Match(RFC4512ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == RFC4512ParserSP {
		{
			p.SetState(1789)
			p.Match(RFC4512ParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserLineComment {
		{
			p.SetState(1795)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1798)
		p.CloseParen()
	}
	p.SetState(1802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1799)
				p.Match(RFC4512ParserSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1805)
			p.Match(RFC4512ParserLineComment)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeDescriptionContext is an interface to support dynamic dispatch.
type IAttributeDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OID() IOIDContext
	AttrOptions() IAttrOptionsContext

	// IsAttributeDescriptionContext differentiates from other interfaces.
	IsAttributeDescriptionContext()
}

type AttributeDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeDescriptionContext() *AttributeDescriptionContext {
	var p = new(AttributeDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attributeDescription
	return p
}

func InitEmptyAttributeDescriptionContext(p *AttributeDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attributeDescription
}

func (*AttributeDescriptionContext) IsAttributeDescriptionContext() {}

func NewAttributeDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeDescriptionContext {
	var p = new(AttributeDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_attributeDescription

	return p
}

func (s *AttributeDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeDescriptionContext) OID() IOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOIDContext)
}

func (s *AttributeDescriptionContext) AttrOptions() IAttrOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttrOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttrOptionsContext)
}

func (s *AttributeDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterAttributeDescription(s)
	}
}

func (s *AttributeDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitAttributeDescription(s)
	}
}

func (p *RFC4512Parser) AttributeDescription() (localctx IAttributeDescriptionContext) {
	localctx = NewAttributeDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, RFC4512ParserRULE_attributeDescription)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1808)
		p.OID()
	}
	p.SetState(1810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == RFC4512ParserT__0 {
		{
			p.SetState(1809)
			p.AttrOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOIDContext is an interface to support dynamic dispatch.
type IOIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Descriptor() IDescriptorContext
	NumericOID() INumericOIDContext

	// IsOIDContext differentiates from other interfaces.
	IsOIDContext()
}

type OIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOIDContext() *OIDContext {
	var p = new(OIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oID
	return p
}

func InitEmptyOIDContext(p *OIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_oID
}

func (*OIDContext) IsOIDContext() {}

func NewOIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OIDContext {
	var p = new(OIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_oID

	return p
}

func (s *OIDContext) GetParser() antlr.Parser { return s.parser }

func (s *OIDContext) Descriptor() IDescriptorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptorContext)
}

func (s *OIDContext) NumericOID() INumericOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDContext)
}

func (s *OIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterOID(s)
	}
}

func (s *OIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitOID(s)
	}
}

func (p *RFC4512Parser) OID() (localctx IOIDContext) {
	localctx = NewOIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, RFC4512ParserRULE_oID)
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserDescr:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1812)
			p.Descriptor()
		}

	case RFC4512ParserNumOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1813)
			p.NumericOID()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpenParenContext is an interface to support dynamic dispatch.
type IOpenParenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParenthesis() antlr.TerminalNode

	// IsOpenParenContext differentiates from other interfaces.
	IsOpenParenContext()
}

type OpenParenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenParenContext() *OpenParenContext {
	var p = new(OpenParenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_openParen
	return p
}

func InitEmptyOpenParenContext(p *OpenParenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_openParen
}

func (*OpenParenContext) IsOpenParenContext() {}

func NewOpenParenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenParenContext {
	var p = new(OpenParenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_openParen

	return p
}

func (s *OpenParenContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenParenContext) OpenParenthesis() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserOpenParenthesis, 0)
}

func (s *OpenParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenParenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterOpenParen(s)
	}
}

func (s *OpenParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitOpenParen(s)
	}
}

func (p *RFC4512Parser) OpenParen() (localctx IOpenParenContext) {
	localctx = NewOpenParenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, RFC4512ParserRULE_openParen)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.Match(RFC4512ParserOpenParenthesis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICloseParenContext is an interface to support dynamic dispatch.
type ICloseParenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CloseParenthesis() antlr.TerminalNode

	// IsCloseParenContext differentiates from other interfaces.
	IsCloseParenContext()
}

type CloseParenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseParenContext() *CloseParenContext {
	var p = new(CloseParenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_closeParen
	return p
}

func InitEmptyCloseParenContext(p *CloseParenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_closeParen
}

func (*CloseParenContext) IsCloseParenContext() {}

func NewCloseParenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseParenContext {
	var p = new(CloseParenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_closeParen

	return p
}

func (s *CloseParenContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseParenContext) CloseParenthesis() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserCloseParenthesis, 0)
}

func (s *CloseParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseParenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterCloseParen(s)
	}
}

func (s *CloseParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitCloseParen(s)
	}
}

func (p *RFC4512Parser) CloseParen() (localctx ICloseParenContext) {
	localctx = NewCloseParenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, RFC4512ParserRULE_closeParen)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1818)
		p.Match(RFC4512ParserCloseParenthesis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericOIDOrMacroContext is an interface to support dynamic dispatch.
type INumericOIDOrMacroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Macro() IMacroContext
	NumericOID() INumericOIDContext

	// IsNumericOIDOrMacroContext differentiates from other interfaces.
	IsNumericOIDOrMacroContext()
}

type NumericOIDOrMacroContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericOIDOrMacroContext() *NumericOIDOrMacroContext {
	var p = new(NumericOIDOrMacroContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_numericOIDOrMacro
	return p
}

func InitEmptyNumericOIDOrMacroContext(p *NumericOIDOrMacroContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_numericOIDOrMacro
}

func (*NumericOIDOrMacroContext) IsNumericOIDOrMacroContext() {}

func NewNumericOIDOrMacroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericOIDOrMacroContext {
	var p = new(NumericOIDOrMacroContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_numericOIDOrMacro

	return p
}

func (s *NumericOIDOrMacroContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericOIDOrMacroContext) Macro() IMacroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroContext)
}

func (s *NumericOIDOrMacroContext) NumericOID() INumericOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOIDContext)
}

func (s *NumericOIDOrMacroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericOIDOrMacroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericOIDOrMacroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterNumericOIDOrMacro(s)
	}
}

func (s *NumericOIDOrMacroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitNumericOIDOrMacro(s)
	}
}

func (p *RFC4512Parser) NumericOIDOrMacro() (localctx INumericOIDOrMacroContext) {
	localctx = NewNumericOIDOrMacroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, RFC4512ParserRULE_numericOIDOrMacro)
	p.SetState(1822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case RFC4512ParserDescr:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1820)
			p.Macro()
		}

	case RFC4512ParserNumOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1821)
			p.NumericOID()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMacroContext is an interface to support dynamic dispatch.
type IMacroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Descriptor() IDescriptorContext
	MacroSuffix() IMacroSuffixContext

	// IsMacroContext differentiates from other interfaces.
	IsMacroContext()
}

type MacroContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroContext() *MacroContext {
	var p = new(MacroContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_macro
	return p
}

func InitEmptyMacroContext(p *MacroContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_macro
}

func (*MacroContext) IsMacroContext() {}

func NewMacroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroContext {
	var p = new(MacroContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_macro

	return p
}

func (s *MacroContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroContext) Descriptor() IDescriptorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptorContext)
}

func (s *MacroContext) MacroSuffix() IMacroSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroSuffixContext)
}

func (s *MacroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMacro(s)
	}
}

func (s *MacroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMacro(s)
	}
}

func (p *RFC4512Parser) Macro() (localctx IMacroContext) {
	localctx = NewMacroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, RFC4512ParserRULE_macro)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1824)
		p.Descriptor()
	}
	{
		p.SetState(1825)
		p.MacroSuffix()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericOIDContext is an interface to support dynamic dispatch.
type INumericOIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumOID() antlr.TerminalNode

	// IsNumericOIDContext differentiates from other interfaces.
	IsNumericOIDContext()
}

type NumericOIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericOIDContext() *NumericOIDContext {
	var p = new(NumericOIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_numericOID
	return p
}

func InitEmptyNumericOIDContext(p *NumericOIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_numericOID
}

func (*NumericOIDContext) IsNumericOIDContext() {}

func NewNumericOIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericOIDContext {
	var p = new(NumericOIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_numericOID

	return p
}

func (s *NumericOIDContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericOIDContext) NumOID() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserNumOID, 0)
}

func (s *NumericOIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericOIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericOIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterNumericOID(s)
	}
}

func (s *NumericOIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitNumericOID(s)
	}
}

func (p *RFC4512Parser) NumericOID() (localctx INumericOIDContext) {
	localctx = NewNumericOIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, RFC4512ParserRULE_numericOID)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1827)
		p.Match(RFC4512ParserNumOID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMacroSuffixContext is an interface to support dynamic dispatch.
type IMacroSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MacroSuffix() antlr.TerminalNode

	// IsMacroSuffixContext differentiates from other interfaces.
	IsMacroSuffixContext()
}

type MacroSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroSuffixContext() *MacroSuffixContext {
	var p = new(MacroSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_macroSuffix
	return p
}

func InitEmptyMacroSuffixContext(p *MacroSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_macroSuffix
}

func (*MacroSuffixContext) IsMacroSuffixContext() {}

func NewMacroSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroSuffixContext {
	var p = new(MacroSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_macroSuffix

	return p
}

func (s *MacroSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroSuffixContext) MacroSuffix() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserMacroSuffix, 0)
}

func (s *MacroSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterMacroSuffix(s)
	}
}

func (s *MacroSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitMacroSuffix(s)
	}
}

func (p *RFC4512Parser) MacroSuffix() (localctx IMacroSuffixContext) {
	localctx = NewMacroSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, RFC4512ParserRULE_macroSuffix)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Match(RFC4512ParserMacroSuffix)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Digit() antlr.TerminalNode

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserDigit, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *RFC4512Parser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, RFC4512ParserRULE_number)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1831)
		p.Match(RFC4512ParserDigit)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttrOptionsContext is an interface to support dynamic dispatch.
type IAttrOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDescriptor() []IDescriptorContext
	Descriptor(i int) IDescriptorContext

	// IsAttrOptionsContext differentiates from other interfaces.
	IsAttrOptionsContext()
}

type AttrOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttrOptionsContext() *AttrOptionsContext {
	var p = new(AttrOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attrOptions
	return p
}

func InitEmptyAttrOptionsContext(p *AttrOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_attrOptions
}

func (*AttrOptionsContext) IsAttrOptionsContext() {}

func NewAttrOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttrOptionsContext {
	var p = new(AttrOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_attrOptions

	return p
}

func (s *AttrOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AttrOptionsContext) AllDescriptor() []IDescriptorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDescriptorContext); ok {
			len++
		}
	}

	tst := make([]IDescriptorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDescriptorContext); ok {
			tst[i] = t.(IDescriptorContext)
			i++
		}
	}

	return tst
}

func (s *AttrOptionsContext) Descriptor(i int) IDescriptorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptorContext)
}

func (s *AttrOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttrOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttrOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterAttrOptions(s)
	}
}

func (s *AttrOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitAttrOptions(s)
	}
}

func (p *RFC4512Parser) AttrOptions() (localctx IAttrOptionsContext) {
	localctx = NewAttrOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, RFC4512ParserRULE_attrOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == RFC4512ParserT__0 {
		{
			p.SetState(1833)
			p.Match(RFC4512ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1834)
			p.Descriptor()
		}

		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescriptorContext is an interface to support dynamic dispatch.
type IDescriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Descr() antlr.TerminalNode

	// IsDescriptorContext differentiates from other interfaces.
	IsDescriptorContext()
}

type DescriptorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptorContext() *DescriptorContext {
	var p = new(DescriptorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_descriptor
	return p
}

func InitEmptyDescriptorContext(p *DescriptorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_descriptor
}

func (*DescriptorContext) IsDescriptorContext() {}

func NewDescriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptorContext {
	var p = new(DescriptorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_descriptor

	return p
}

func (s *DescriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptorContext) Descr() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserDescr, 0)
}

func (s *DescriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterDescriptor(s)
	}
}

func (s *DescriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitDescriptor(s)
	}
}

func (p *RFC4512Parser) Descriptor() (localctx IDescriptorContext) {
	localctx = NewDescriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, RFC4512ParserRULE_descriptor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1839)
		p.Match(RFC4512ParserDescr)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensionValueContext is an interface to support dynamic dispatch.
type IExtensionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuotedString() antlr.TerminalNode
	QuotedDescriptor() antlr.TerminalNode

	// IsExtensionValueContext differentiates from other interfaces.
	IsExtensionValueContext()
}

type ExtensionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionValueContext() *ExtensionValueContext {
	var p = new(ExtensionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_extensionValue
	return p
}

func InitEmptyExtensionValueContext(p *ExtensionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = RFC4512ParserRULE_extensionValue
}

func (*ExtensionValueContext) IsExtensionValueContext() {}

func NewExtensionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionValueContext {
	var p = new(ExtensionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC4512ParserRULE_extensionValue

	return p
}

func (s *ExtensionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionValueContext) QuotedString() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserQuotedString, 0)
}

func (s *ExtensionValueContext) QuotedDescriptor() antlr.TerminalNode {
	return s.GetToken(RFC4512ParserQuotedDescriptor, 0)
}

func (s *ExtensionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.EnterExtensionValue(s)
	}
}

func (s *ExtensionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC4512Listener); ok {
		listenerT.ExitExtensionValue(s)
	}
}

func (p *RFC4512Parser) ExtensionValue() (localctx IExtensionValueContext) {
	localctx = NewExtensionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, RFC4512ParserRULE_extensionValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RFC4512ParserQuotedDescriptor || _la == RFC4512ParserQuotedString) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
